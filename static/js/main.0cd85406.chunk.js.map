{"version":3,"sources":["components/video-screen/VideoScreen.tsx","modules/websocket.service.ts","components/message/Message.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["VideoScreen","react_default","a","createElement","id","this","props","idAttr","className","React","Component","WebSocketService","ws","user","onMessageCb","onRegisterCb","cb","_this","WebSocket","onmessage","e","data","JSON","parse","action","payload","Error","from","send","stringify","message","name","to","Message","item","App","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","toNameRef","createRef","toMessageRef","handleOnSendMessageClick","nameValue","current","value","messageValue","communicate","state","messages","_this2","Container","Row","Col","VideoScreen_VideoScreen","Button","onClick","handleOnRegisterClick","variant","ref","placeholder","type","map","index","Message_Message","key","_this3","connect","onRegister","result","setState","onMessage","concat","toConsumableArray","prompt","register","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.0cd85406.chunk.js","sourcesContent":["import React from 'react';\nimport './VideoScreen.css';\n\nexport interface IVideoScreenProps {\n  idAttr: string;\n}\n\nexport default class VideoScreen extends React.Component<IVideoScreenProps, any> {\n  render() {\n    return (\n      <video id={this.props.idAttr} className=\"video\"></video>\n    );\n  }\n}","const SOCKET_URL = 'wss://r12aimxa21.execute-api.eu-west-2.amazonaws.com/Prod';\n\nexport interface IMessage {\n  from: string;\n  to?: string;\n  message: string;\n}\n\nexport default class WebSocketService {\n  ws: WebSocket | null = null;\n  user: string | null = null;\n  onMessageCb: (msg: any) => void = () => {};\n  onRegisterCb: (result: boolean, name?: string) => void = () => {};\n\n  setUser(user: string) {\n    this.user = user;\n  }\n\n  onMessage(cb: (msg: any) => void) {\n    this.onMessageCb = cb;\n  }\n\n  onRegister(cb: (result: boolean, name?: string) => void) {\n    this.onRegisterCb = cb;\n  }\n\n  connect() {\n    this.ws = new WebSocket(SOCKET_URL);\n    this.ws.onmessage = (e) => {\n      const data = JSON.parse(e.data);\n\n      switch (data.action) {\n        case 'registerSuccess':\n          this.onRegisterCb(true, data.payload);\n          break;\n        \n        case 'communticate':\n          this.onMessageCb(data.payload);\n          break;\n      \n        default:\n          this.onRegisterCb(false);\n          break;\n      }\n    }\n  }\n\n  send(data: any) {\n    if (!this.ws) {\n      throw new Error('Connection is lost or has not been established yet');\n    }\n\n    if (this.user) {\n      data.from = this.user;\n    }\n\n    this.ws.send(JSON.stringify({\n      message: 'sendmessage',\n      data\n    }));\n  }\n\n  register(name: string) {\n    this.send({\n      action: 'register',\n      payload: name\n    });\n  }\n\n  communicate(to: string, message:string) {\n    this.send({\n      action: 'communicate',\n      payload: {\n        to,\n        message\n      }\n    });\n  }\n}","import React from 'react';\nimport { IMessage } from '../../modules/websocket.service';\nimport './Message.css';\n\nexport interface IMessageProps {\n  item: IMessage\n}\n\nexport default class Message extends React.Component<IMessageProps, object> {\n  render() {\n    return (<div className=\"message\">\n      <span className=\"message__title\">{this.props.item.from}</span>\n      <div>{this.props.item.message}</div>\n    </div>);\n  }\n}","import React, { RefObject } from 'react';\nimport { Container, Row, Col, Button } from 'react-bootstrap';\nimport VideoScreen from './components/video-screen/VideoScreen';\nimport './App.css';\nimport WebSocketService, { IMessage } from './modules/websocket.service';\nimport Message from './components/message/Message';\n\ninterface IAppState {\n  name: string | null;\n  messages: IMessage[];\n}\n\nclass App extends React.Component<unknown, IAppState> {\n  ws: WebSocketService = new WebSocketService();\n  toNameRef: RefObject<HTMLInputElement> = React.createRef<HTMLInputElement>();\n  toMessageRef: RefObject<HTMLTextAreaElement> = React.createRef<HTMLTextAreaElement>();\n\n  constructor(props: unknown) {\n    super(props);\n\n    this.state = {\n      name: null,\n      messages: []\n    };\n  }\n\n  render() {\n    return (\n      <Container>\n        <Row>\n          <Col>\n            <VideoScreen idAttr=\"self\" />\n          </Col>\n          <Col>\n            <VideoScreen idAttr=\"remote\" />\n          </Col>\n        </Row>\n        <Row>\n          <Col>\n            <Button onClick={() => this.handleOnRegisterClick()} variant=\"success\">Register</Button>\n          </Col>\n          <Col>\n            <Button variant=\"danger\">Abort call</Button>\n          </Col>\n          <Col>Logged in as: {this.state.name}</Col>\n        </Row>\n        <Row>\n          <Col>\n            <input ref={this.toNameRef} placeholder=\"Message to...\" type=\"text\"/>\n            <textarea ref={this.toMessageRef} placeholder=\"Message body...\"></textarea>\n          </Col>\n          <Col>\n            <Button onClick={this.handleOnSendMessageClick} variant=\"success\">Send message</Button>\n          </Col>\n          <Col>\n            Messages: {this.state.messages.map((message, index) => (\n              <Message item={message} key={index} />\n            ))}\n          </Col>\n        </Row>\n      </Container>\n    );\n  }\n\n  componentWillMount() {\n    this.ws.connect();\n\n    this.ws.onRegister((result, name) => {\n      this.setState({name: result && name ? name : null});\n    });\n\n    this.ws.onMessage((message: IMessage) => {\n      this.setState({\n        messages: [\n          ...this.state.messages,\n          message\n        ]\n      })\n    });\n  }\n\n  handleOnRegisterClick() {\n    const name = prompt('Enter a name');\n    if (name) {\n      this.ws.register(name);\n    }\n  }\n\n  handleOnSendMessageClick = () => {\n    const nameValue = this.toNameRef.current && this.toNameRef.current.value;\n    const messageValue = this.toMessageRef.current && this.toMessageRef.current.value;\n\n    if (!nameValue || !messageValue) {\n      return;\n    }\n\n    this.ws.communicate(nameValue, messageValue);\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'bootstrap/dist/css/bootstrap.css';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}