{"version":3,"sources":["components/video-screen/VideoScreen.tsx","modules/websocket.service.ts","components/message/Message.tsx","modules/webrtc.service.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["VideoScreen","react_default","a","createElement","autoPlay","muted","id","this","props","idAttr","className","React","Component","WebSocketService","ws","user","_this2","WebSocket","onmessage","e","data","JSON","parse","action","emit","result","name","payload","Error","from","send","stringify","message","to","EventEmitter","Message","item","WebRTCService","serverConnection","_this","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","peerUserName","localVideo","localStream","remoteVideo","peerConnection","dataChannel","receiveChannel","uuid","peerConnectionConfig","iceServers","urls","gotMessageFromServer","start","signal","sdp","setRemoteDescription","RTCSessionDescription","then","type","createAnswer","createdDescription","catch","errorHandler","ice","addIceCandidate","RTCIceCandidate","gotIceCandidate","event","candidate","communicate","description","setLocalDescription","localDescription","gotRemoteStream","srcObject","streams","getUserMediaSuccess","stream","error","console","log","createUUID","document","getElementById","on","navigator","mediaDevices","getUserMedia","video","audio","alert","isCaller","undefined","RTCPeerConnection","onicecandidate","ontrack","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","getTracks","Symbol","iterator","next","done","track","value","addTrack","err","return","dc","createDataChannel","messgage","onopen","onclose","ondatachannel","channel","createOffer","isDataChannelReady","getDisplayMedia","s4","Math","floor","random","toString","substring","App","webRtc","toNameRef","createRef","toMessageRef","handleOnStartCallClick","nameValue","current","grabScreen","handleOnSendMessageClick","messageValue","state","messages","Container","Row","Col","VideoScreen_VideoScreen","Button","onClick","handleOnRegisterClick","variant","ref","placeholder","map","index","key","Message_Message","_this3","connect","_ref","setState","concat","toConsumableArray","initWebRTC","prompt","register","init","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.405785bb.chunk.js","sourcesContent":["import React from 'react';\nimport './VideoScreen.css';\n\nexport interface IVideoScreenProps {\n  idAttr: string;\n}\n\nexport default class VideoScreen extends React.Component<IVideoScreenProps, any> {\n  render() {\n    return (\n      <video autoPlay muted id={this.props.idAttr} className=\"video\"></video>\n    );\n  }\n}","import {EventEmitter} from 'eventemitter3';\n\nconst SOCKET_URL = 'wss://r12aimxa21.execute-api.eu-west-2.amazonaws.com/Prod';\n\nexport interface IMessage {\n  from: string;\n  to?: string;\n  message: string;\n}\n\nexport default class WebSocketService extends EventEmitter {\n  ws: WebSocket | null = null;\n  user: string | null = null;\n\n  setUser(user: string) {\n    this.user = user;\n  }\n\n  connect() {\n    this.ws = new WebSocket(SOCKET_URL);\n    this.ws.onmessage = (e) => {\n      const data = JSON.parse(e.data);\n\n      switch (data.action) {\n        case 'registerSuccess':\n          this.emit('register', {\n            result: true,\n            name: data.payload\n          });\n          break;\n        \n        case 'communticate':\n          this.emit('communticate', data.payload);\n          break;\n      \n        default:\n          this.emit('register', {\n            result: false,\n            name: null\n          });\n          break;\n      }\n    }\n  }\n\n  send(data: any) {\n    if (!this.ws) {\n      throw new Error('Connection is lost or has not been established yet');\n    }\n\n    if (this.user) {\n      data.from = this.user;\n    }\n\n    this.ws.send(JSON.stringify({\n      message: 'sendmessage',\n      data\n    }));\n  }\n\n  register(name: string) {\n    this.send({\n      action: 'register',\n      payload: name\n    });\n  }\n\n  communicate(to: string, message:string) {\n    this.send({\n      action: 'communicate',\n      payload: {\n        to,\n        message\n      }\n    });\n  }\n}","import React from 'react';\nimport { IMessage } from '../../modules/websocket.service';\nimport './Message.css';\n\nexport interface IMessageProps {\n  item: IMessage\n}\n\nexport default class Message extends React.Component<IMessageProps, object> {\n  render() {\n    return (<div className=\"message\">\n      <span className=\"message__title\">{this.props.item.from}</span>\n      <div>{this.props.item.message}</div>\n    </div>);\n  }\n}","import WebSocketService, { IMessage } from \"./websocket.service\";\nimport { EventEmitter } from \"eventemitter3\";\n\nexport interface ISignalMessage {\n  uuid: string;\n  ice?: RTCIceCandidateInit;\n  sdp?: RTCSessionDescriptionInit;\n}\n\ninterface ISignalMessageSdp extends ISignalMessage {\n  sdp: RTCSessionDescriptionInit;\n}\n\nexport default class WebRTCService extends EventEmitter {\n  peerUserName: string | null = null;\n  localVideo: HTMLVideoElement | null = null;\n  localStream: MediaStream | null = null;\n  remoteVideo: HTMLVideoElement | null = null;\n  peerConnection: RTCPeerConnection | null = null;\n  dataChannel: RTCDataChannel | null = null;\n  receiveChannel: RTCDataChannel | null = null;\n  uuid: string | null = null;\n  \n  peerConnectionConfig = {\n    'iceServers': [\n      {'urls': 'stun:stun.stunprotocol.org:3478'},\n      {'urls': 'stun:stun.l.google.com:19302'},\n    ]\n  };\n\n  constructor(private serverConnection: WebSocketService) {\n      super();\n  }\n  \n  init(localVideo: string, remoteVideo: string) {\n    this.uuid = this.createUUID();\n  \n    this.localVideo = document.getElementById(localVideo) as HTMLVideoElement;\n    this.remoteVideo = document.getElementById(remoteVideo) as HTMLVideoElement;\n\n    this.serverConnection.on('communticate', this.gotMessageFromServer);\n  \n    const constraints = {\n      video: true,\n      audio: true,\n    };\n  \n    if(navigator.mediaDevices.getUserMedia) {\n      navigator.mediaDevices.getUserMedia(constraints)\n        .then(this.getUserMediaSuccess)\n        .catch(this.errorHandler);\n    } else {\n      alert('Your browser does not support getUserMedia API');\n    }\n  }\n\n  start(peerUserName?: string) {\n    const isCaller = peerUserName !== undefined;\n    if (!this.localStream) {\n      throw new Error('No localStream');\n    }\n\n    const peerConnection = new RTCPeerConnection(this.peerConnectionConfig);\n    peerConnection.onicecandidate = this.gotIceCandidate;\n    peerConnection.ontrack = this.gotRemoteStream;\n\n    for (const track of this.localStream.getTracks()) {\n      peerConnection.addTrack(track, this.localStream);\n    }\n\n    this.peerConnection = peerConnection;\n\n    let dc = peerConnection.createDataChannel('datachannel');\n    \n    dc.onmessage = (event) => {\n      const messgage: IMessage = {\n        from: this.peerUserName as string,\n        message: event.data\n      }\n      this.emit('communticate', messgage);\n      console.log(\"received: \" + event.data);\n    };\n    \n    dc.onopen = () => {\n      this.dataChannel = dc;\n      console.log(\"datachannel open\");\n    };\n    \n    dc.onclose = () => {\n      this.dataChannel = null;\n      console.log(\"datachannel close\");\n    };\n    \n    peerConnection.ondatachannel = (event) => {\n      this.receiveChannel = event.channel;\n      this.receiveChannel.onclose = () => {\n        this.receiveChannel = null;\n      }\n\n      this.receiveChannel.onmessage = (event) => {\n        console.log(\"received: \" + event.data);\n        const messgage: IMessage = {\n          from: this.peerUserName as string,\n          message: event.data\n        }\n        this.emit('communticate', messgage);\n      };\n    }\n\n    if(isCaller) {\n      this.peerUserName = peerUserName as string;\n\n      peerConnection.createOffer()\n        .then(this.createdDescription)\n        .catch(this.errorHandler);\n    }\n  }\n  \n  isDataChannelReady() {\n    return !!this.receiveChannel && !!this.dataChannel;\n  }\n  \n  communicate(message: string) {\n    if (!this.isDataChannelReady()) {\n      throw new Error('DC is not available now');\n    }\n\n    (this.dataChannel as RTCDataChannel).send(message);\n  }\n\n  grabScreen() {\n    if(navigator.mediaDevices.getUserMedia) {\n      return (navigator.mediaDevices as any).getDisplayMedia({video: true})\n        .then(this.getUserMediaSuccess)\n        .catch(this.errorHandler);\n    } else {\n      alert('Your browser does not support getDisplayMedia API');\n    } \n  }\n\n  private gotMessageFromServer = (message: IMessage) => {\n    if(!this.peerConnection) {\n      this.start();\n    }\n    const peerConnection = this.peerConnection as RTCPeerConnection;\n    let signal: ISignalMessage;\n    try {\n      signal = JSON.parse(message.message);\n    } catch (e) {\n      return;\n    }\n  \n    // Ignore messages from ourself\n    if(!signal.uuid || signal.uuid === this.uuid) return;\n    this.peerUserName = message.from;\n\n    if(signal.sdp) {\n      const sdp = (signal as ISignalMessageSdp).sdp;\n      peerConnection.setRemoteDescription(new RTCSessionDescription(signal.sdp))\n      .then(() => {\n        // Only create answers in response to offers\n        if(sdp.type === 'offer') {\n          peerConnection.createAnswer().then(this.createdDescription).catch(this.errorHandler);\n        }\n      }).catch(this.errorHandler);\n    } else if(signal.ice) {\n      peerConnection.addIceCandidate(new RTCIceCandidate(signal.ice)).catch(this.errorHandler);\n    }\n  }\n\n  private gotIceCandidate = (event: RTCPeerConnectionIceEvent) => {\n    if (event.candidate != null) {\n      this.serverConnection.communicate(this.peerUserName as string, JSON.stringify({\n        ice: event.candidate,\n        uuid: this.uuid\n      }));\n    }\n  }\n\n  private createdDescription = (description: RTCSessionDescriptionInit) => {\n    const peerConnection = this.peerConnection;\n    if (!peerConnection) {\n      throw new Error('No peerConnection');\n    }\n  \n    peerConnection.setLocalDescription(description).then(() => {\n      this.serverConnection\n        .communicate(this.peerUserName as string, JSON.stringify({\n          'sdp': peerConnection.localDescription,\n          'uuid': this.uuid\n        }));\n    }).catch(this.errorHandler);\n  }\n\n  private gotRemoteStream = (event: RTCTrackEvent) => {\n    if (!this.remoteVideo) {\n      throw new Error('No remoteVideo element');\n    }\n\n    this.remoteVideo.srcObject = event.streams[0];\n  }\n\n  private getUserMediaSuccess = (stream: MediaStream) => {\n    if (!this.localVideo) {\n      throw new Error('No localVideo element');\n    }\n    this.localStream = stream;\n    this.localVideo.srcObject = stream;\n  }\n  \n  private errorHandler = (error: any) => {\n    console.log(error);\n  }\n  \n  // Taken from http://stackoverflow.com/a/105074/515584\n  // Strictly speaking, it's not a real UUID, but it gets the job done here\n  private createUUID() {\n    function s4() {\n      return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n    }\n\n    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n  }\n\n}\n\n\n\n\n\n\n\n","import React, { RefObject } from 'react';\nimport { Container, Row, Col, Button } from 'react-bootstrap';\nimport VideoScreen from './components/video-screen/VideoScreen';\nimport './App.css';\nimport WebSocketService, { IMessage } from './modules/websocket.service';\nimport Message from './components/message/Message';\nimport WebRTCService from './modules/webrtc.service';\n\ninterface IAppState {\n  name: string | null;\n  messages: IMessage[];\n}\n\nclass App extends React.Component<unknown, IAppState> {\n  ws: WebSocketService = new WebSocketService();\n  webRtc: WebRTCService = new WebRTCService(this.ws);\n\n  toNameRef: RefObject<HTMLInputElement> = React.createRef<HTMLInputElement>();\n  toMessageRef: RefObject<HTMLTextAreaElement> = React.createRef<HTMLTextAreaElement>();\n\n  constructor(props: unknown) {\n    super(props);\n\n    this.state = {\n      name: null,\n      messages: []\n    };\n  }\n\n  render() {\n    return (\n      <Container>\n        <Row>\n          <Col>\n            <VideoScreen idAttr=\"localVideo\" />\n          </Col>\n          <Col>\n            <VideoScreen idAttr=\"remoteVideo\" />\n          </Col>\n        </Row>\n        <Row>\n          <Col>\n            <Button onClick={() => this.handleOnRegisterClick()} variant=\"primary\">Register</Button>\n          </Col>\n          <Col>\n            <Button onClick={this.handleOnStartCallClick} variant=\"success\">Call</Button>\n            <Button variant=\"danger\">Abort call</Button>\n          </Col>\n          <Col>Logged in as: {this.state.name}</Col>\n        </Row>\n        <Row>\n          <Col>\n            <input ref={this.toNameRef} placeholder=\"Message to...\" type=\"text\"/>\n            <textarea ref={this.toMessageRef} placeholder=\"Message body...\"></textarea>\n          </Col>\n          <Col>\n            <Button onClick={this.handleOnSendMessageClick} variant=\"secondary\">Send message</Button>\n          </Col>\n          <Col>\n            Messages: {this.state.messages.map((message, index) => (\n              <div key={index}>\n                <Message item={message} />\n                <hr/>\n              </div>\n            ))}\n          </Col>\n        </Row>\n      </Container>\n    );\n  }\n\n  componentDidMount() {\n    this.ws.connect();\n\n    this.ws.on('register', ({result, name}) => {\n      this.setState({name: result && name ? name : null});\n    });\n\n    this.ws.on('communticate', (message: IMessage) => {\n      this.setState({\n        messages: [\n          ...this.state.messages,\n          message\n        ]\n      })\n    });\n    \n    this.webRtc.on('communticate', (message: IMessage) => {\n      this.setState({\n        messages: [\n          ...this.state.messages,\n          message\n        ]\n      })\n    });\n\n    this.initWebRTC();\n  }\n\n  handleOnRegisterClick() {\n    const name = prompt('Enter a name');\n    if (name) {\n      this.ws.register(name);\n    }\n  }\n\n  handleOnStartCallClick = () => {\n    const nameValue = this.toNameRef.current && this.toNameRef.current.value;\n    if (!nameValue) {\n      return;\n    }\n\n    this.webRtc.grabScreen().then(() => {\n      this.webRtc.start(nameValue);\n    });\n    \n  }\n\n  handleOnSendMessageClick = () => {\n    const nameValue = this.toNameRef.current && this.toNameRef.current.value;\n    const messageValue = this.toMessageRef.current && this.toMessageRef.current.value;\n\n    if (!nameValue || !messageValue) {\n      return;\n    }\n\n    if (this.webRtc.dataChannel) {\n      this.webRtc.communicate(messageValue);\n    } else {\n      this.ws.communicate(nameValue, messageValue);\n    }\n    \n  }\n\n  private initWebRTC() {\n    this.webRtc.init('localVideo', 'remoteVideo');\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'bootstrap/dist/css/bootstrap.css';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}