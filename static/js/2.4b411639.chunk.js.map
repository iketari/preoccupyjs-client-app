{"version":3,"sources":["../node_modules/preoccupyjs/preoccupyjs.es5.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/inherits.js","../node_modules/eventemitter3/index.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread.js"],"names":["__webpack_require__","d","__webpack_exports__","createClient","Host","TransportEvents","Message","EventEmitter","_extendStatics","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","ActionsName","_assign","assign","t","s","i","n","arguments","length","call","apply","BaseAction","payload","type","handleEvent","host","event","console","warn","BASE","MoveToAction","_super","_this","performEvent","dom","stack","moveCursorTo","getRelativeCoordinate","MOVE_TO","eventName","ClickToAction","clickTo","CLICK_TO","KeypressAction","keypress","key","code","keyCode","KEYPRESS","ScrollByAction","scroll","coordinates","deltaX","shiftKey","deltaY","SCROLL_BY","DblClickToAction","dblClickTo","DBL_CLICK_TO","pick","src","fields","reduce","result","field","KeydownAction","keydown","KEYDOWN","KeyupAction","keyup","KEYUP","RightClickToAction","rightClickTo","e","preventDefault","button","RIGHT_CLICK_TO","MouseDownToAction","mouseDownTo","MOUSE_DOWN_TO","MouseUpToAction","mouseUpTo","MOUSE_UP_TO","actionMap","Map","map","Action","tryCatchTarget","listeners","off","undefined","on","callback","push","trigger","detail","isArray","forEach","data","hash","Math","random","serialize","JSON","stringify","parse","_a","split","dataSrc","LocalTransport","preifx","stackSize","connected","publishedMessages","storage","localStorage","handshake","connect","disconnect","cleanUp","window","removeEventListener","publish","action","message","setItem","messageToDelete","shift","removeItem","onStorageMessage","addEventListener","keys","startsWith","newValue","isExternalMessage","find","ownMessage","errorObject","tryCatcher","tryCatch","fn","isFunction","x","_enable_super_gross_mode_that_will_cause_bad_things","config","Promise","useDeprecatedSynchronousErrorHandling","value","Error","hostReportError","err","setTimeout","empty","closed","next","error","complete","isObject","UnsubscriptionError","errors","toString","join","name","Subscription","unsubscribe","_parent","_parents","_subscriptions","_unsubscribe","hasErrors","index","len","remove","flattenUnsubscriptionErrors","sub","concat","add","teardown","EMPTY","subscription","_addParent","tmp","subscriptions","subscriptionIndex","indexOf","splice","parent","errs","rxSubscriber","Symbol","for","Subscriber","destinationOrNext","syncErrorValue","syncErrorThrown","syncErrorThrowable","isStopped","destination","isTrustedSubscriber","trustedSubscriber","SafeSubscriber","subscriber","_next","_error","_complete","_unsubscribeAndRecycle","_parentSubscriber","observerOrNext","context","bind","_context","__tryOrSetError","__tryOrUnsub","wrappedComplete","obj","observable","noop","Observable","subscribe","_isScalar","_subscribe","lift","operator","observable$$1","source","sink","nextOrObserver","toSubscriber","_trySubscribe","promiseCtor","getPromiseCtor","resolve","reject","pipe","fns","operations","_i","input","prev","toPromise","FilterOperator","predicate","thisArg","FilterSubscriber","count","SubjectSubscriber","RefCountOperator","connectable","_refCount","refCounter","RefCountSubscriber","connection","refCount","sharedConnection","_connection","connectableProto","ConnectableObservable","subjectFactory","_isComplete","getSubject","subject","_subject","ConnectableSubscriber","RxjsTransport","options","filterFn","rawData","Boolean","wrapFn","Client","transport","actionStack","actions","perform","rawAction","has","get","start","init","stop","destroy","Cursor","el","createCursorEl","moveTo","y","style","transform","getEl","document","createElement","styles","entries","_b","prop","setProperty","css","z-index","position","top","left","width","height","display","background","DomController","cursor","bodyEl","body","getComputedStyle","appendChild","absCoordinates","getAbsoluteCoordinates","getMouseEventPayload","fireEvent","activeElement","setFocus","getElementFromPoint","tagName","toLowerCase","select","inputEl","includes","slice","isContentEditable","innerHTML","String","fromCharCode","scrollableEl","parentElement","isScrollable","scrollBy","clientX","clientY","view","innerHeight","innerWidth","elementFromPoint","focus","defaultOptions","bubbles","cancelable","MouseEvent","KeyboardEvent","Event","log","dispatchEvent","isScrollableY","isScrollableX","overflowX","scrollWidth","clientWidth","overflowY","scrollHeight","clientHeight","eventCallbacks","WeakMap","initEvents","disableEvents","set","offsetX","offsetY","target","localTransport","_classCallCheck","instance","Constructor","TypeError","_defineProperties","props","descriptor","enumerable","configurable","writable","defineProperty","_createClass","protoProps","staticProps","_getPrototypeOf","o","getPrototypeOf","_typeof2","iterator","_typeof","_possibleConstructorReturn","self","ReferenceError","_assertThisInitialized","_setPrototypeOf","_inherits","subClass","superClass","prefix","Events","EE","once","addListener","emitter","listener","evt","_events","_eventsCount","clearEvent","eventNames","events","names","getOwnPropertySymbols","handlers","l","ee","listenerCount","emit","a1","a2","a3","a4","a5","args","removeListener","j","removeAllListeners","prefixed","module","exports","_toConsumableArray","arr","arr2","_arrayWithoutHoles","iter","from","_iterableToArray","_nonIterableSpread","_defineProperty","_objectSpread","ownKeys","filter","sym","getOwnPropertyDescriptor"],"mappings":"sFAAAA,EAAAC,EAAAC,EAAA,sBAAAC,KAAAH,EAAAC,EAAAC,EAAA,sBAAAE,KAAAJ,EAAAC,EAAAC,EAAA,sBAAAG,IAAAL,EAAAC,EAAAC,EAAA,sBAAAI,IAAAN,EAAAC,EAAAC,EAAA,sBAAAK,IAgBA,IAAAC,EAAA,SAAAP,EAAAQ,GAWA,OAVAD,EAAAE,OAAAC,gBAAA,CACAC,UAAA,cACGC,OAAA,SAAAZ,EAAAQ,GACHR,EAAAW,UAAAH,IACG,SAAAR,EAAAQ,GACH,QAAAK,KAAAL,EACAA,EAAAM,eAAAD,KAAAb,EAAAa,GAAAL,EAAAK,MAIAb,EAAAQ,IAGA,SAAAO,EAAAf,EAAAQ,GAGA,SAAAQ,IACAC,KAAAC,YAAAlB,EAHAO,EAAAP,EAAAQ,GAMAR,EAAAmB,UAAA,OAAAX,EAAAC,OAAAW,OAAAZ,IAAAQ,EAAAG,UAAAX,EAAAW,UAAA,IAAAH,GAGA,IAgBAK,EAhBAC,EAAA,WAaA,OAZAA,EAAAb,OAAAc,QAAA,SAAAC,GACA,QAAAC,EAAAC,EAAA,EAAAC,EAAAC,UAAAC,OAA4CH,EAAAC,EAAOD,IAGnD,QAAAb,KAFAY,EAAAG,UAAAF,GAGAjB,OAAAU,UAAAL,eAAAgB,KAAAL,EAAAZ,KAAAW,EAAAX,GAAAY,EAAAZ,IAIA,OAAAW,IAGAO,MAAAd,KAAAW,aAKA,SAAAP,GACAA,EAAA,qBACAA,EAAA,2BACAA,EAAA,sCACAA,EAAA,kCACAA,EAAA,6BACAA,EAAA,yCACAA,EAAA,wCACAA,EAAA,6BACAA,EAAA,2BACAA,EAAA,uBACAA,EAAA,+BAXA,CAYCA,MAAA,KAED,IAAAW,EAEA,WACA,SAAAA,EAAAC,QACA,IAAAA,IACAA,EAAA,IAGAhB,KAAAgB,UACAhB,KAAAiB,KAAAF,EAAAE,KASA,OANAF,EAAAG,YAAA,SAAAC,EAAAC,GAEA,OADAC,QAAAC,KAAA,yDAAAtB,KAAAiB,KAAA,WACA,IAGAF,EAAAE,KAAAb,EAAAmB,KACAR,EAhBA,GAmBAS,EAEA,SAAAC,GAGA,SAAAD,EAAAR,GACA,IAAAU,EAAAD,EAAAZ,KAAAb,YAIA,OAFA0B,EAAAV,UACAU,EAAAT,KAAAO,EAAAP,KACAS,EAcA,OArBA5B,EAAA0B,EAAAC,GAUAD,EAAAtB,UAAAyB,aAAA,SAAAC,EAAAC,GACAD,EAAAE,aAAA9B,KAAAgB,UAGAQ,EAAAN,YAAA,SAAAC,EAAAC,GAEA,WAAAI,EADAL,EAAAY,sBAAAX,KAIAI,EAAAP,KAAAb,EAAA4B,QACAR,EAAAS,UAAA,YACAT,EAtBA,CAuBCT,GAEDmB,EAEA,SAAAT,GAGA,SAAAS,EAAAlB,GACA,IAAAU,EAAAD,EAAAZ,KAAAb,YAIA,OAFA0B,EAAAV,UACAU,EAAAT,KAAAiB,EAAAjB,KACAS,EAcA,OArBA5B,EAAAoC,EAAAT,GAUAS,EAAAhC,UAAAyB,aAAA,SAAAC,EAAAC,GACAD,EAAAO,QAAAnC,KAAAgB,UAGAkB,EAAAhB,YAAA,SAAAC,EAAAC,GAEA,WAAAc,EADAf,EAAAY,sBAAAX,KAIAc,EAAAjB,KAAAb,EAAAgC,SACAF,EAAAD,UAAA,QACAC,EAtBA,CAuBCnB,GAEDsB,EAEA,SAAAZ,GAGA,SAAAY,EAAArB,GACA,IAAAU,EAAAD,EAAAZ,KAAAb,YAIA,OAFA0B,EAAAV,UACAU,EAAAT,KAAAoB,EAAApB,KACAS,EAiBA,OAxBA5B,EAAAuC,EAAAZ,GAUAY,EAAAnC,UAAAyB,aAAA,SAAAC,EAAAC,GACAD,EAAAU,SAAAtC,KAAAgB,UAGAqB,EAAAnB,YAAA,SAAAC,EAAAC,GACA,WAAAiB,EAAA,CACAE,IAAAnB,EAAAmB,IACAC,KAAApB,EAAAoB,KACAC,QAAArB,EAAAqB,WAIAJ,EAAApB,KAAAb,EAAAsC,SACAL,EAAAJ,UAAA,WACAI,EAzBA,CA0BCtB,GAED4B,EAEA,SAAAlB,GAGA,SAAAkB,EAAA3B,GACA,IAAAU,EAAAD,EAAAZ,KAAAb,YAIA,OAFA0B,EAAAV,UACAU,EAAAT,KAAA0B,EAAA1B,KACAS,EAiBA,OAxBA5B,EAAA6C,EAAAlB,GAUAkB,EAAAzC,UAAAyB,aAAA,SAAAC,EAAAC,GACAD,EAAAgB,OAAA5C,KAAAgB,UAGA2B,EAAAzB,YAAA,SAAAC,EAAAC,GACA,IAAAyB,EAAA1B,EAAAY,sBAAAX,GACA,WAAAuB,EAAAtC,EAAA,GAAwCwC,EAAA,CACxCC,OAAA1B,EAAA2B,SAAA3B,EAAA4B,OAAA,EACAA,OAAA5B,EAAA2B,SAAA,EAAA3B,EAAA4B,WAIAL,EAAA1B,KAAAb,EAAA6C,UACAN,EAAAV,UAAA,aACAU,EAzBA,CA0BC5B,GAEDmC,EAEA,SAAAzB,GAGA,SAAAyB,EAAAlC,GACA,IAAAU,EAAAD,EAAAZ,KAAAb,YAIA,OAFA0B,EAAAV,UACAU,EAAAT,KAAAiC,EAAAjC,KACAS,EAcA,OArBA5B,EAAAoD,EAAAzB,GAUAyB,EAAAhD,UAAAyB,aAAA,SAAAC,EAAAC,GACAD,EAAAuB,WAAAnD,KAAAgB,UAGAkC,EAAAhC,YAAA,SAAAC,EAAAC,GAEA,WAAA8B,EADA/B,EAAAY,sBAAAX,KAIA8B,EAAAjC,KAAAb,EAAAgD,aACAF,EAAAjB,UAAA,WACAiB,EAtBA,CAuBCnC,GAWD,SAAAsC,EAAAC,EAAAC,GAKA,YAJA,IAAAA,IACAA,EAAA,IAGAA,EAAAC,OAAA,SAAAC,EAAAC,GAEA,OADAD,EAAAC,GAAAJ,EAAAI,GACAD,GACG,IAGH,IAkJAtE,EAhJAwE,EAEA,SAAAlC,GAGA,SAAAkC,EAAA3C,GACA,IAAAU,EAAAD,EAAAZ,KAAAb,YAIA,OAFA0B,EAAAV,UACAU,EAAAT,KAAA0C,EAAA1C,KACAS,EAcA,OArBA5B,EAAA6D,EAAAlC,GAUAkC,EAAAzD,UAAAyB,aAAA,SAAAC,EAAAC,GACAD,EAAAgC,QAAA5D,KAAAgB,UAGA2C,EAAAzC,YAAA,SAAAC,EAAAC,GAEA,WAAAuC,EADAN,EAAAjC,EAAA,0EAIAuC,EAAA1C,KAAAb,EAAAyD,QACAF,EAAA1B,UAAA,UACA0B,EAtBA,CAuBC5C,GAED+C,EAEA,SAAArC,GAGA,SAAAqC,EAAA9C,GACA,IAAAU,EAAAD,EAAAZ,KAAAb,YAIA,OAFA0B,EAAAV,UACAU,EAAAT,KAAA6C,EAAA7C,KACAS,EAcA,OArBA5B,EAAAgE,EAAArC,GAUAqC,EAAA5D,UAAAyB,aAAA,SAAAC,EAAAC,GACAD,EAAAmC,MAAA/D,KAAAgB,UAGA8C,EAAA5C,YAAA,SAAAC,EAAAC,GAEA,WAAA0C,EADAT,EAAAjC,EAAA,0EAIA0C,EAAA7C,KAAAb,EAAA4D,MACAF,EAAA7B,UAAA,QACA6B,EAtBA,CAuBC/C,GAEDkD,EAEA,SAAAxC,GAGA,SAAAwC,EAAAjD,GACA,IAAAU,EAAAD,EAAAZ,KAAAb,YAIA,OAFA0B,EAAAV,UACAU,EAAAT,KAAAgD,EAAAhD,KACAS,EAoBA,OA3BA5B,EAAAmE,EAAAxC,GAUAwC,EAAA/D,UAAAyB,aAAA,SAAAC,EAAAC,GACAD,EAAAsC,aAAAlE,KAAAgB,UAGAiD,EAAA/C,YAAA,SAAAC,EAAAC,GACA,IAAA+C,EAAA/C,EAOA,OANAA,EAAAgD,iBAMA,IAAAH,EAJA5D,EAAA,GAA4Bc,EAAAY,sBAAAoC,GAAA,CAC5BE,OAAAF,EAAAE,WAMAJ,EAAAhD,KAAAb,EAAAkE,eACAL,EAAAhC,UAAA,cACAgC,EA5BA,CA6BClD,GAEDwD,EAEA,SAAA9C,GAGA,SAAA8C,EAAAvD,GACA,IAAAU,EAAAD,EAAAZ,KAAAb,YAIA,OAFA0B,EAAAV,UACAU,EAAAT,KAAAsD,EAAAtD,KACAS,EAcA,OArBA5B,EAAAyE,EAAA9C,GAUA8C,EAAArE,UAAAyB,aAAA,SAAAC,EAAAC,GACAD,EAAA4C,YAAAxE,KAAAgB,UAGAuD,EAAArD,YAAA,SAAAC,EAAAC,GAEA,WAAAmD,EADApD,EAAAY,sBAAAX,KAIAmD,EAAAtD,KAAAb,EAAAqE,cACAF,EAAAtC,UAAA,YACAsC,EAtBA,CAuBCxD,GAED2D,EAEA,SAAAjD,GAGA,SAAAiD,EAAA1D,GACA,IAAAU,EAAAD,EAAAZ,KAAAb,YAIA,OAFA0B,EAAAV,UACAU,EAAAT,KAAAyD,EAAAzD,KACAS,EAcA,OArBA5B,EAAA4E,EAAAjD,GAUAiD,EAAAxE,UAAAyB,aAAA,SAAAC,EAAAC,GACAD,EAAA+C,UAAA3E,KAAAgB,UAGA0D,EAAAxD,YAAA,SAAAC,EAAAC,GAEA,WAAAsD,EADAvD,EAAAY,sBAAAX,KAIAsD,EAAAzD,KAAAb,EAAAwE,YACAF,EAAAzC,UAAA,UACAyC,EAtBA,CAuBC3D,GAED8D,EAAA,IAAAC,IAAA,CAAAtD,EAAAU,EAAAyB,EAAAtB,EAAAyB,EAAAtC,EAAAmB,EAAAO,EAAAe,EAAAM,EAAAG,GAAAK,IAAA,SAAAC,GACA,OAAAA,EAAA/D,KAAA+D,OAIA,SAAA7F,GACAA,IAAA,qBACAA,IAAA,2BACAA,IAAA,mBAHA,CAICA,MAAA,KAED,IA6KA8F,EA7KA5F,EAEA,WACA,SAAAA,IACAW,KAAAkF,UAAA,GA+BA,OA5BA7F,EAAAa,UAAAiF,IAAA,SAAAlE,QACAmE,IAAAnE,EAKAjB,KAAAkF,UAAAjE,GAAA,GAJAjB,KAAAkF,UAAA,IAOA7F,EAAAa,UAAAmF,GAAA,SAAApE,EAAAqE,GACAtF,KAAAkF,UAAAjE,KACAjB,KAAAkF,UAAAjE,GAAA,IAGAjB,KAAAkF,UAAAjE,GAAAsE,KAAAD,IAGAjG,EAAAa,UAAAsF,QAAA,SAAAvE,EAAAwE,GACA9F,MAAA+F,QAAA1F,KAAAkF,UAAAjE,KACAjB,KAAAkF,UAAAjE,GAAA0E,QAAA,SAAAL,GACA,OAAAA,EAAA,CACArE,OACAwE,cAMApG,EAjCA,GAoCAD,EAEA,WACA,SAAAA,EAAA6B,EAAA2E,EAAAC,GACA7F,KAAAiB,OACAjB,KAAA4F,OACA5F,KAAA6F,QAAA,IAAAC,KAAAC,SAAA,GAiBA,OAdA3G,EAAAc,UAAA8F,UAAA,WACA,OAAAC,KAAAC,UAAAlG,KAAA4F,OAGAxG,EAAA+G,MAAA,SAAA7C,GACA,IAAA8C,EAAA9C,EAAA+C,MAAA,KAEApF,GADAmF,EAAA,GACAA,EAAA,IACAP,EAAAO,EAAA,GACAE,EAAAF,EAAA,GAEA,WAAAhH,EAAA6B,EAAAgF,KAAAE,MAAAG,GAAAT,IAGAzG,EArBA,GAwBAmH,EAEA,SAAA9E,GAGA,SAAA8E,EAAAC,EAAAC,QACA,IAAAD,IACAA,EAAA,eAGA,IAAAC,IACAA,EAAA,IAGA,IAAA/E,EAAAD,EAAAZ,KAAAb,YAOA,OALA0B,EAAA8E,SACA9E,EAAA+E,YACA/E,EAAAgF,WAAA,EACAhF,EAAAiF,kBAAA,GACAjF,EAAAkF,QAAAC,aACAnF,EA8EA,OAhGA5B,EAAAyG,EAAA9E,GAqBA8E,EAAArG,UAAA4G,UAAA,WACA9G,KAAA0G,UACA1G,KAAAwF,QAAArG,EAAA4H,SAEA/G,KAAA+G,WAIAR,EAAArG,UAAA8G,WAAA,WACAhH,KAAAiH,UACAC,OAAAC,oBAAA,UAAAnH,MACAA,KAAAmF,MACAnF,KAAA0G,WAAA,GAGAH,EAAArG,UAAAkH,QAAA,SAAAC,GACA,IAAAC,EAAA,IAAAlI,EAAA,SAAAiI,GAIA,GAHArH,KAAA2G,kBAAApB,KAAA+B,GACAtH,KAAA4G,QAAAW,QAAAvH,KAAAwG,OAAA,IAAAc,EAAArG,KAAA,IAAAqG,EAAAzB,KAAAyB,EAAAtB,aAEAhG,KAAA2G,kBAAA/F,OAAAZ,KAAAyG,UAAA,CACA,IAAAe,EAAAxH,KAAA2G,kBAAAc,QAEAD,GACAxH,KAAA4G,QAAAc,WAAA1H,KAAAwG,OAAA,IAAAgB,EAAAvG,KAAA,IAAAuG,EAAA3B,QAKAU,EAAArG,UAAAgB,YAAA,SAAAE,GACA,OAAAA,EAAAH,MACA,cACAjB,KAAA2H,iBAAAvG,KAQAmF,EAAArG,UAAA6G,QAAA,WACAG,OAAAU,iBAAA,UAAA5H,MACAA,KAAA0G,WAAA,EACA1G,KAAAwF,QAAArG,EAAA4H,UAGAR,EAAArG,UAAA+G,QAAA,WACA,IAAAvF,EAAA1B,KAEAR,OAAAqI,KAAAhB,cAAAlB,QAAA,SAAApD,GACAA,EAAAuF,WAAApG,EAAA8E,SACAK,aAAAa,WAAAnF,MAKAgE,EAAArG,UAAAyH,iBAAA,SAAAvB,GACA,IAAA7D,EAAA6D,EAAA7D,IACAwF,EAAA3B,EAAA2B,SAEA,GAAAxF,GAAAwF,GAAAxF,EAAAuF,WAAA9H,KAAAwG,QAAA,CACA,IAAAc,EAAAlI,EAAA+G,MAAA5D,EAAA,IAAAwF,GAEA/H,KAAAgI,kBAAAV,IACAtH,KAAAwF,QAAArG,EAAAkI,OAAAC,KAKAf,EAAArG,UAAA8H,kBAAA,SAAAV,GACA,OAAAtH,KAAA2G,kBAAAsB,KAAA,SAAAC,GACA,OAAAA,EAAArC,OAAAyB,EAAAzB,QAIAU,EAjGA,CAkGClH,GAID8I,EAAA,CACAhE,EAAA,IAMA,SAAAiE,IACA,IACA,OAAAnD,EAAAnE,MAAAd,KAAAW,WACG,MAAAwD,GAEH,OADAgE,EAAAhE,IACAgE,GAIA,SAAAE,EAAAC,GAEA,OADArD,EAAAqD,EACAF,EAKA,SAAAG,EAAAC,GACA,0BAAAA,EAKA,IAAAC,GAAA,EACAC,EAAA,CACAC,aAAAvD,EAEAwD,0CAAAC,GACAA,IAGA,IAAAC,OAGAjH,MAMA4G,EAAAI,GAGAD,4CACA,OAAAH,IAMA,SAAAM,EAAAC,GACAC,WAAA,WACA,MAAAD,IAMA,IAAAE,EAAA,CACAC,QAAA,EACAC,KAAA,SAAAP,KACAQ,MAAA,SAAAL,GACA,GAAAN,EAAAE,sCACA,MAAAI,EAEAD,EAAAC,IAGAM,SAAA,cAIA5D,EAAA/F,MAAA+F,SAAA,SAAA8C,GACA,OAAAA,GAAA,kBAAAA,EAAA5H,QAKA,SAAA2I,EAAAf,GACA,aAAAA,GAAA,kBAAAA,EAKA,IAAAgB,EAEA,SAAA/H,GAGA,SAAA+H,EAAAC,GACA,IAAA/H,EAAAD,EAAAZ,KAAAb,KAAAyJ,IAAA7I,OAAA,8CAAA6I,EAAA1E,IAAA,SAAAiE,EAAAvI,GACA,OAAAA,EAAA,OAAAuI,EAAAU,aACKC,KAAA,aAAA3J,KAKL,OAHA0B,EAAA+H,SACA/H,EAAAkI,KAAA,sBACApK,OAAAC,eAAAiC,EAAA8H,EAAAtJ,WACAwB,EAGA,OAbA5B,EAAA0J,EAAA/H,GAaA+H,EAdA,CAeCV,OAIDe,EAEA,WACA,SAAAA,EAAAC,GACA9J,KAAAmJ,QAAA,EACAnJ,KAAA+J,QAAA,KACA/J,KAAAgK,SAAA,KACAhK,KAAAiK,eAAA,KAEAH,IACA9J,KAAAkK,aAAAJ,GAyIA,IAAAZ,EAKA,OA1IAW,EAAA3J,UAAA4J,YAAA,WACA,IACAL,EADAU,GAAA,EAGA,IAAAnK,KAAAmJ,OAAA,CAIA,IACAY,EADA/J,KACA+J,QACAC,EAFAhK,KAEAgK,SACAE,EAHAlK,KAGAkK,aACAD,EAJAjK,KAIAiK,eAEAjK,KAAAmJ,QAAA,EACAnJ,KAAA+J,QAAA,KACA/J,KAAAgK,SAAA,KACAhK,KAAAiK,eAAA,KAIA,IAHA,IAAAG,GAAA,EACAC,EAAAL,IAAApJ,OAAA,EAEAmJ,GACAA,EAAAO,OAAAtK,MAEA+J,IAAAK,EAAAC,GAAAL,EAAAI,IAAA,KAGA,GAAA7B,EAAA2B,GACA7B,EAAA6B,GAAArJ,KAAAb,QAEAmI,IACAgC,GAAA,EACAV,MAAAtB,EAAAhE,aAAAqF,EAAAe,EAAApC,EAAAhE,EAAAsF,QAAA,CAAAtB,EAAAhE,KAIA,GAAAuB,EAAAuE,GAIA,IAHAG,GAAA,EACAC,EAAAJ,EAAArJ,SAEAwJ,EAAAC,GAAA,CACA,IAAAG,EAAAP,EAAAG,GAEA,GAAAb,EAAAiB,GAGA,GAFAnC,EAAAmC,EAAAV,aAAAjJ,KAAA2J,KAEArC,EAAA,CACAgC,GAAA,EACAV,KAAA,GACA,IAAAT,EAAAb,EAAAhE,EAEA6E,aAAAQ,EACAC,IAAAgB,OAAAF,EAAAvB,EAAAS,SAEAA,EAAAlE,KAAAyD,IAOA,GAAAmB,EACA,UAAAX,EAAAC,KAIAI,EAAA3J,UAAAwK,IAAA,SAAAC,GACA,IAAAA,OAAAd,EAAAe,MACA,OAAAf,EAAAe,MAGA,GAAAD,IAAA3K,KACA,OAAAA,KAGA,IAAA6K,EAAAF,EAEA,cAAAA,GACA,eACAE,EAAA,IAAAhB,EAAAc,GAEA,aACA,GAAAE,EAAA1B,QAAA,oBAAA0B,EAAAf,YACA,OAAAe,EACS,GAAA7K,KAAAmJ,OAET,OADA0B,EAAAf,cACAe,EACS,uBAAAA,EAAAC,WAAA,CACT,IAAAC,EAAAF,GACAA,EAAA,IAAAhB,GACAI,eAAA,CAAAc,GAGA,MAEA,QACA,UAAAjC,MAAA,yBAAA6B,EAAA,2BAQA,OALA3K,KAAAiK,iBAAAjK,KAAAiK,eAAA,KACA1E,KAAAsF,GAEAA,EAAAC,WAAA9K,MAEA6K,GAGAhB,EAAA3J,UAAAoK,OAAA,SAAAO,GACA,IAAAG,EAAAhL,KAAAiK,eAEA,GAAAe,EAAA,CACA,IAAAC,EAAAD,EAAAE,QAAAL,IAEA,IAAAI,GACAD,EAAAG,OAAAF,EAAA,KAKApB,EAAA3J,UAAA4K,WAAA,SAAAM,GACA,IACArB,EADA/J,KACA+J,QACAC,EAFAhK,KAEAgK,SAEAD,OAAAqB,EAEKpB,GAEA,IAAAA,EAAAkB,QAAAE,IACLpB,EAAAzE,KAAA6F,GAFApL,KAAAgK,SAAA,CAAAoB,GAFApL,KAAA+J,QAAAqB,GAQAvB,EAAAe,QAAA1B,EAGG,IAAAW,GAFHV,QAAA,EACAD,GAGAW,EAtJA,GAyJA,SAAAU,EAAAd,GACA,OAAAA,EAAAjG,OAAA,SAAA6H,EAAArC,GACA,OAAAqC,EAAAZ,OAAAzB,aAAAQ,EAAAR,EAAAS,OAAAT,IACG,IAKH,IAAAsC,EAAA,oBAAAC,QAAA,oBAAAA,OAAAC,IAEAD,OAAAC,IAAA,iCAGAC,EAEA,SAAAhK,GAGA,SAAAgK,EAAAC,EAAArC,EAAAC,GACA,IAAA5H,EAAAD,EAAAZ,KAAAb,YAOA,OALA0B,EAAAiK,eAAA,KACAjK,EAAAkK,iBAAA,EACAlK,EAAAmK,oBAAA,EACAnK,EAAAoK,WAAA,EAEAnL,UAAAC,QACA,OACAc,EAAAqK,YAAA7C,EACA,MAEA,OACA,IAAAwC,EAAA,CACAhK,EAAAqK,YAAA7C,EACA,MAGA,qBAAAwC,EAAA,CACA,GAAAM,EAAAN,GAAA,CACA,IAAAO,EAAAP,EAAAJ,KACA5J,EAAAmK,mBAAAI,EAAAJ,mBACAnK,EAAAqK,YAAAE,EACAA,EAAAvB,IAAAhJ,QAEAA,EAAAmK,oBAAA,EACAnK,EAAAqK,YAAA,IAAAG,EAAAxK,EAAAgK,GAGA,MAGA,QACAhK,EAAAmK,oBAAA,EACAnK,EAAAqK,YAAA,IAAAG,EAAAxK,EAAAgK,EAAArC,EAAAC,GAIA,OAAA5H,EA0EA,OAnHA5B,EAAA2L,EAAAhK,GA4CAgK,EAAAvL,UAAAoL,GAAA,WACA,OAAAtL,MAGAyL,EAAAtL,OAAA,SAAAiJ,EAAAC,EAAAC,GACA,IAAA6C,EAAA,IAAAV,EAAArC,EAAAC,EAAAC,GAEA,OADA6C,EAAAN,oBAAA,EACAM,GAGAV,EAAAvL,UAAAkJ,KAAA,SAAAP,GACA7I,KAAA8L,WACA9L,KAAAoM,MAAAvD,IAIA4C,EAAAvL,UAAAmJ,MAAA,SAAAL,GACAhJ,KAAA8L,YACA9L,KAAA8L,WAAA,EAEA9L,KAAAqM,OAAArD,KAIAyC,EAAAvL,UAAAoJ,SAAA,WACAtJ,KAAA8L,YACA9L,KAAA8L,WAAA,EAEA9L,KAAAsM,cAIAb,EAAAvL,UAAA4J,YAAA,WACA9J,KAAAmJ,SAIAnJ,KAAA8L,WAAA,EAEArK,EAAAvB,UAAA4J,YAAAjJ,KAAAb,QAGAyL,EAAAvL,UAAAkM,MAAA,SAAAvD,GACA7I,KAAA+L,YAAA3C,KAAAP,IAGA4C,EAAAvL,UAAAmM,OAAA,SAAArD,GACAhJ,KAAA+L,YAAA1C,MAAAL,GACAhJ,KAAA8J,eAGA2B,EAAAvL,UAAAoM,UAAA,WACAtM,KAAA+L,YAAAzC,WACAtJ,KAAA8J,eAGA2B,EAAAvL,UAAAqM,uBAAA,WACA,IACAxC,EADA/J,KACA+J,QACAC,EAFAhK,KAEAgK,SASA,OAPAhK,KAAA+J,QAAA,KACA/J,KAAAgK,SAAA,KACAhK,KAAA8J,cACA9J,KAAAmJ,QAAA,EACAnJ,KAAA8L,WAAA,EACA9L,KAAA+J,UACA/J,KAAAgK,WACAhK,MAGAyL,EApHA,CAqHC5B,GAEDqC,EAEA,SAAAzK,GAGA,SAAAyK,EAAAM,EAAAC,EAAApD,EAAAC,GACA,IAGAF,EAHA1H,EAAAD,EAAAZ,KAAAb,YAEA0B,EAAA8K,oBAEA,IAAAE,EAAAhL,EAwBA,OAtBA6G,EAAAkE,GACArD,EAAAqD,EACKA,IACLrD,EAAAqD,EAAArD,KACAC,EAAAoD,EAAApD,MACAC,EAAAmD,EAAAnD,SAEAmD,IAAAvD,IAGAX,GAFAmE,EAAAlN,OAAAW,OAAAsM,IAEA3C,cACApI,EAAAgJ,IAAAgC,EAAA5C,YAAA6C,KAAAD,IAGAA,EAAA5C,YAAApI,EAAAoI,YAAA6C,KAAAjL,KAIAA,EAAAkL,SAAAF,EACAhL,EAAA0K,MAAAhD,EACA1H,EAAA2K,OAAAhD,EACA3H,EAAA4K,UAAAhD,EACA5H,EAwHA,OAvJA5B,EAAAoM,EAAAzK,GAkCAyK,EAAAhM,UAAAkJ,KAAA,SAAAP,GACA,IAAA7I,KAAA8L,WAAA9L,KAAAoM,MAAA,CACA,IAAAI,EAAAxM,KAAAwM,kBAEA9D,EAAAE,uCAAA4D,EAAAX,mBAEO7L,KAAA6M,gBAAAL,EAAAxM,KAAAoM,MAAAvD,IACP7I,KAAA8J,cAFA9J,KAAA8M,aAAA9M,KAAAoM,MAAAvD,KAOAqD,EAAAhM,UAAAmJ,MAAA,SAAAL,GACA,IAAAhJ,KAAA8L,UAAA,CACA,IAAAU,EAAAxM,KAAAwM,kBACA5D,EAAAF,EAAAE,sCAEA,GAAA5I,KAAAqM,OACAzD,GAAA4D,EAAAX,oBAKA7L,KAAA6M,gBAAAL,EAAAxM,KAAAqM,OAAArD,GAEAhJ,KAAA8J,gBANA9J,KAAA8M,aAAA9M,KAAAqM,OAAArD,GAEAhJ,KAAA8J,oBAMO,GAAA0C,EAAAX,mBASPjD,GACA4D,EAAAb,eAAA3C,EACAwD,EAAAZ,iBAAA,GAEA7C,EAAAC,GAGAhJ,KAAA8J,kBAhBO,CAGP,GAFA9J,KAAA8J,cAEAlB,EACA,MAAAI,EAGAD,EAAAC,MAcAkD,EAAAhM,UAAAoJ,SAAA,WACA,IAAA5H,EAAA1B,KAEA,IAAAA,KAAA8L,UAAA,CACA,IAAAU,EAAAxM,KAAAwM,kBAEA,GAAAxM,KAAAsM,UAAA,CACA,IAAAS,EAAA,WACA,OAAArL,EAAA4K,UAAAzL,KAAAa,EAAAkL,WAGAlE,EAAAE,uCAAA4D,EAAAX,oBAKA7L,KAAA6M,gBAAAL,EAAAO,GAEA/M,KAAA8J,gBANA9J,KAAA8M,aAAAC,GAEA/M,KAAA8J,oBAOA9J,KAAA8J,gBAKAoC,EAAAhM,UAAA4M,aAAA,SAAAxE,EAAAO,GACA,IACAP,EAAAzH,KAAAb,KAAA4M,SAAA/D,GACK,MAAAG,GAGL,GAFAhJ,KAAA8J,cAEApB,EAAAE,sCACA,MAAAI,EAEAD,EAAAC,KAKAkD,EAAAhM,UAAA2M,gBAAA,SAAAzB,EAAA9C,EAAAO,GACA,IAAAH,EAAAE,sCACA,UAAAE,MAAA,YAGA,IACAR,EAAAzH,KAAAb,KAAA4M,SAAA/D,GACK,MAAAG,GACL,OAAAN,EAAAE,uCACAwC,EAAAO,eAAA3C,EACAoC,EAAAQ,iBAAA,GACA,IAEA7C,EAAAC,IACA,GAIA,UAGAkD,EAAAhM,UAAAgK,aAAA,WACA,IAAAsC,EAAAxM,KAAAwM,kBACAxM,KAAA4M,SAAA,KACA5M,KAAAwM,kBAAA,KAEAA,EAAA1C,eAGAoC,EAxJA,CAyJCT,GAED,SAAAO,EAAAgB,GACA,OAAAA,aAAAvB,GAAA,uBAAAuB,KAAA1B,GAqFA,IAAA2B,EAAA,oBAAA1B,eAAA0B,YAAA,eAGA,SAAAC,KAsBA,IAAAC,EAEA,WACA,SAAAA,EAAAC,GACApN,KAAAqN,WAAA,EAEAD,IACApN,KAAAsN,WAAAF,GA+GA,OA3GAD,EAAAjN,UAAAqN,KAAA,SAAAC,GACA,IAAAC,EAAA,IAAAN,EAGA,OAFAM,EAAAC,OAAA1N,KACAyN,EAAAD,WACAC,GAGAN,EAAAjN,UAAAkN,UAAA,SAAAX,EAAApD,EAAAC,GACA,IAAAkE,EAAAxN,KAAAwN,SACAG,EAjEA,SAAAC,EAAAvE,EAAAC,GACA,GAAAsE,EAAA,CACA,GAAAA,aAAAnC,EACA,OAAAmC,EAGA,GAAAA,EAAAtC,GACA,OAAAsC,EAAAtC,KAIA,OAAAsC,GAAAvE,GAAAC,EAIA,IAAAmC,EAAAmC,EAAAvE,EAAAC,GAHA,IAAAmC,EAAAvC,GAqDA2E,CAAApB,EAAApD,EAAAC,GAQA,GANAkE,EACAA,EAAA3M,KAAA8M,EAAA3N,KAAA0N,QAEAC,EAAAjD,IAAA1K,KAAA0N,QAAAhF,EAAAE,wCAAA+E,EAAA9B,mBAAA7L,KAAAsN,WAAAK,GAAA3N,KAAA8N,cAAAH,IAGAjF,EAAAE,uCACA+E,EAAA9B,qBACA8B,EAAA9B,oBAAA,EAEA8B,EAAA/B,iBACA,MAAA+B,EAAAhC,eAKA,OAAAgC,GAGAR,EAAAjN,UAAA4N,cAAA,SAAAH,GACA,IACA,OAAA3N,KAAAsN,WAAAK,GACK,MAAA3E,GACLN,EAAAE,wCACA+E,EAAA/B,iBAAA,EACA+B,EAAAhC,eAAA3C,GAGA2E,EAAAtE,MAAAL,KAIAmE,EAAAjN,UAAAyF,QAAA,SAAAyD,EAAA2E,GACA,IAAArM,EAAA1B,KAGA,WADA+N,EAAAC,EAAAD,IACA,SAAAE,EAAAC,GACA,IAAArD,EACAA,EAAAnJ,EAAA0L,UAAA,SAAAvE,GACA,IACAO,EAAAP,GACS,MAAAG,GACTkF,EAAAlF,GAEA6B,GACAA,EAAAf,gBAGOoE,EAAAD,MAIPd,EAAAjN,UAAAoN,WAAA,SAAAnB,GACA,IAAAuB,EAAA1N,KAAA0N,OACA,OAAAA,KAAAN,UAAAjB,IAGAgB,EAAAjN,UAAA+M,GAAA,WACA,OAAAjN,MAGAmN,EAAAjN,UAAAiO,KAAA,WAGA,IAFA,IAtGAC,EAsGAC,EAAA,GAEAC,EAAA,EAAoBA,EAAA3N,UAAAC,OAAuB0N,IAC3CD,EAAAC,GAAA3N,UAAA2N,GAGA,WAAAD,EAAAzN,OACAZ,OA7GAoO,EAgHAC,GA3GA,IAAAD,EAAAxN,OACAwN,EAAA,GAGA,SAAAG,GACA,OAAAH,EAAA5K,OAAA,SAAAgL,EAAAlG,GACA,OAAAA,EAAAkG,IACKD,IAVLrB,GA8GAlN,OAGAmN,EAAAjN,UAAAuO,UAAA,SAAAV,GACA,IAAArM,EAAA1B,KAGA,WADA+N,EAAAC,EAAAD,IACA,SAAAE,EAAAC,GACA,IAAArF,EAEAnH,EAAA0L,UAAA,SAAA5E,GACA,OAAAK,EAAAL,GACO,SAAAQ,GACP,OAAAkF,EAAAlF,IACO,WACP,OAAAiF,EAAApF,QAKAsE,EAAAhN,OAAA,SAAAiN,GACA,WAAAD,EAAAC,IAGAD,EApHA,GAuHA,SAAAa,EAAAD,GAKA,GAJAA,IACAA,EAAArF,EAAAC,mBAGAoF,EACA,UAAAjF,MAAA,yBAGA,OAAAiF,EA09DCjF,MAUD,IAAA4F,EAEA,WACA,SAAAA,EAAAC,EAAAC,GACA5O,KAAA2O,YACA3O,KAAA4O,UAOA,OAJAF,EAAAxO,UAAAW,KAAA,SAAAsL,EAAAuB,GACA,OAAAA,EAAAN,UAAA,IAAAyB,EAAA1C,EAAAnM,KAAA2O,UAAA3O,KAAA4O,WAGAF,EAVA,GAaAG,EAEA,SAAApN,GAGA,SAAAoN,EAAA9C,EAAA4C,EAAAC,GACA,IAAAlN,EAAAD,EAAAZ,KAAAb,KAAA+L,IAAA/L,KAKA,OAHA0B,EAAAiN,YACAjN,EAAAkN,UACAlN,EAAAoN,MAAA,EACApN,EAkBA,OA1BA5B,EAAA+O,EAAApN,GAWAoN,EAAA3O,UAAAkM,MAAA,SAAAvD,GACA,IAAApF,EAEA,IACAA,EAAAzD,KAAA2O,UAAA9N,KAAAb,KAAA4O,QAAA/F,EAAA7I,KAAA8O,SACK,MAAA9F,GAEL,YADAhJ,KAAA+L,YAAA1C,MAAAL,GAIAvF,GACAzD,KAAA+L,YAAA3C,KAAAP,IAIAgG,EA3BA,CA4BCpD,GAwfDsD,GAraCjG,MAyXAA,MA8CD,SAAArH,GAGA,SAAAsN,EAAAhD,GACA,IAAArK,EAAAD,EAAAZ,KAAAb,KAAA+L,IAAA/L,KAGA,OADA0B,EAAAqK,cACArK,EAGA,OATA5B,EAAAiP,EAAAtN,GASAsN,EAVA,CAWCtD,IAkrBD,IAAAuD,EAEA,WACA,SAAAA,EAAAC,GACAjP,KAAAiP,cAgBA,OAbAD,EAAA9O,UAAAW,KAAA,SAAAsL,EAAAuB,GACA,IAAAuB,EAAAjP,KAAAiP,YACAA,EAAAC,YACA,IAAAC,EAAA,IAAAC,EAAAjD,EAAA8C,GACApE,EAAA6C,EAAAN,UAAA+B,GAMA,OAJAA,EAAAhG,SACAgG,EAAAE,WAAAJ,EAAAlI,WAGA8D,GAGAmE,EAlBA,GAqBAI,EAEA,SAAA3N,GAGA,SAAA2N,EAAArD,EAAAkD,GACA,IAAAvN,EAAAD,EAAAZ,KAAAb,KAAA+L,IAAA/L,KAGA,OADA0B,EAAAuN,cACAvN,EAmCA,OAzCA5B,EAAAsP,EAAA3N,GASA2N,EAAAlP,UAAAgK,aAAA,WACA,IAAA+E,EAAAjP,KAAAiP,YAEA,GAAAA,EAAA,CAKAjP,KAAAiP,YAAA,KACA,IAAAK,EAAAL,EAAAC,UAEA,GAAAI,GAAA,EACAtP,KAAAqP,WAAA,UAMA,GAFAJ,EAAAC,UAAAI,EAAA,EAEAA,EAAA,EACAtP,KAAAqP,WAAA,SADA,CAKA,IAAAA,EAAArP,KAAAqP,WACAE,EAAAN,EAAAO,YACAxP,KAAAqP,WAAA,MAEAE,GAAAF,GAAAE,IAAAF,GACAE,EAAAzF,oBAxBA9J,KAAAqP,WAAA,MA4BAD,EA1CA,CA2CC3D,GA2DDgE,EArDA,SAAAhO,GAGA,SAAAiO,EAAAhC,EAAAiC,GACA,IAAAjO,EAAAD,EAAAZ,KAAAb,YAMA,OAJA0B,EAAAgM,SACAhM,EAAAiO,iBACAjO,EAAAwN,UAAA,EACAxN,EAAAkO,aAAA,EACAlO,EAwCA,OAjDA5B,EAAA4P,EAAAjO,GAYAiO,EAAAxP,UAAAoN,WAAA,SAAAnB,GACA,OAAAnM,KAAA6P,aAAAzC,UAAAjB,IAGAuD,EAAAxP,UAAA2P,WAAA,WACA,IAAAC,EAAA9P,KAAA+P,SAMA,OAJAD,MAAAhE,YACA9L,KAAA+P,SAAA/P,KAAA2P,kBAGA3P,KAAA+P,UAGAL,EAAAxP,UAAA6G,QAAA,WACA,IAAAsI,EAAArP,KAAAwP,YAeA,OAbAH,IACArP,KAAA4P,aAAA,GACAP,EAAArP,KAAAwP,YAAA,IAAA3F,GACAa,IAAA1K,KAAA0N,OAAAN,UAAA,IAAA4C,EAAAhQ,KAAA6P,aAAA7P,QAEAqP,EAAAlG,QACAnJ,KAAAwP,YAAA,KACAH,EAAAxF,EAAAe,OAEA5K,KAAAwP,YAAAH,GAIAA,GAGAK,EAAAxP,UAAAoP,SAAA,WACA,OA9HA5B,EA8HA1N,MA7HAuN,KAAA,IAAAyB,EAAAtB,IADA,IAAAA,GAiIAgC,EAlDA,CAmDCvC,GAEDjN,UAmCA8P,GAjBAP,EAAAnC,WAGAmC,EAAAG,YAIAH,EAAAI,WAGAJ,EAAA1I,QAGA0I,EAAAH,SAMA,SAAA7N,GAGA,SAAAuO,EAAAjE,EAAAkD,GACA,IAAAvN,EAAAD,EAAAZ,KAAAb,KAAA+L,IAAA/L,KAGA,OADA0B,EAAAuN,cACAvN,EAiCA,OAvCA5B,EAAAkQ,EAAAvO,GASAuO,EAAA9P,UAAAmM,OAAA,SAAArD,GACAhJ,KAAAkK,eAEAzI,EAAAvB,UAAAmM,OAAAxL,KAAAb,KAAAgJ,IAGAgH,EAAA9P,UAAAoM,UAAA,WACAtM,KAAAiP,YAAAW,aAAA,EAEA5P,KAAAkK,eAEAzI,EAAAvB,UAAAoM,UAAAzL,KAAAb,OAGAgQ,EAAA9P,UAAAgK,aAAA,WACA,IAAA+E,EAAAjP,KAAAiP,YAEA,GAAAA,EAAA,CACAjP,KAAAiP,YAAA,KACA,IAAAI,EAAAJ,EAAAO,YACAP,EAAAC,UAAA,EACAD,EAAAc,SAAA,KACAd,EAAAO,YAAA,KAEAH,GACAA,EAAAvF,gBAKAkG,EAxCA,CAyCCjB,IA4pDAjG,OAs6BD,SAAArH,GAGA,SAAAwO,EAAAC,GACA,IAAAxO,EAAAD,EAAAZ,KAAAb,YAaA,OAXA0B,EAAAmJ,aAAA,KACAnJ,EAAAgF,WAAA,EACAhF,EAAAoO,QAAAI,EAAAJ,QACApO,EAAAyO,cAAA/K,IAAA8K,EAAAC,SAAA,SAAAC,GACA,OAAAC,QAAAD,IACKF,EAAAC,SACLzO,EAAA4O,YAAAlL,IAAA8K,EAAAI,OAAA,SAAAhJ,GACA,OACA1B,KAAA0B,EAAAtB,cAEKkK,EAAAI,OACL5O,EAhBA5B,EAAAmQ,EAAAxO,GAmBAwO,EAAA/P,UAAA8G,WAAA,WACAhH,KAAAmF,MACAnF,KAAA6K,cAAA7K,KAAA6K,aAAAf,cACA9J,KAAA0G,WAAA,GAGAuJ,EAAA/P,UAAAkH,QAAA,SAAAC,GACA,IAAAC,EAAA,IAAAlI,EAAA,SAAAiI,GACArH,KAAA8P,QAAA1G,KAAApJ,KAAAsQ,OAAAhJ,KAGA2I,EAAA/P,UAAA4G,UAAA,WACA9G,KAAA0G,UACA1G,KAAAwF,QAAArG,EAAA4H,SAEA/G,KAAA+G,WAIAkJ,EAAA/P,UAAA6G,QAAA,WACA,IAjiIA4H,EAAAC,EAiiIAlN,EAAA1B,KAEAA,KAAA6K,aAAA7K,KAAA8P,QAAA3B,MAniIAQ,EAmiIA,SAAAyB,GACA,OAAA1O,EAAAyO,SAAAC,IAniIA,SAAA1C,GACA,OAAAA,EAAAH,KAAA,IAAAmB,EAAAC,EAAAC,OAmiIKxB,UAAA,SAAAxH,GACL,IAAA0B,EAAAlI,EAAA+G,MAAA,MAAAP,QAEAlE,EAAA8D,QAAArG,EAAAkI,OAAAC,KAEAtH,KAAAwF,QAAArG,EAAA4H,QAAA,OAjDA,CAqDC1H,GA9lBD,IAkmBAkR,EAEA,WACA,SAAAA,EAAAC,EAAA5O,GACA5B,KAAAwQ,YACAxQ,KAAA4B,MACA5B,KAAAyQ,YAAA,GACAzQ,KAAA0Q,QAAA7L,EAmCA,OAhCA0L,EAAArQ,UAAAyQ,QAAA,SAAAC,GACA,GAAA5Q,KAAA0Q,QAAAG,IAAAD,EAAA3P,MAAA,CACA,IACAoG,EAAA,IADArH,KAAA0Q,QAAAI,IAAAF,EAAA3P,MACA,CAAA2P,EAAA5P,SAIA,IAHAqG,EAAA1F,aAAA3B,KAAA4B,IAAA5B,KAAAyQ,aACAzQ,KAAAyQ,YAAAlL,KAAA8B,GAEArH,KAAAyQ,YAAA7P,OAnBA,IAoBAZ,KAAAyQ,YAAAhJ,UAKA8I,EAAArQ,UAAA6Q,MAAA,WACA,IAAArP,EAAA1B,KAEAA,KAAAwQ,UAAAnL,GAAAlG,EAAA4H,QAAA,SAAA3F,GACAM,EAAAE,IAAAoP,SAEAhR,KAAAwQ,UAAAnL,GAAAlG,EAAAkI,OAAA,SAAAjG,GACA,IAAAkG,EAAAlG,EAAAqE,OAEA/D,EAAAiP,QAAArJ,EAAA1B,QAEA5F,KAAAwQ,UAAA1J,aAGAyJ,EAAArQ,UAAA+Q,KAAA,WACAjR,KAAAwQ,UAAAxJ,aACAhH,KAAA4B,IAAAsP,WAGAX,EAxCA,GA2CAY,GAEA,WACA,SAAAA,IACAnR,KAAAoR,GAAApR,KAAAqR,iBAgCA,OA7BAF,EAAAjR,UAAAoR,OAAA,SAAAlL,GACA,IAAAoC,EAAApC,EAAAoC,EACA+I,EAAAnL,EAAAmL,EACAvR,KAAAoR,GAAAI,MAAAC,UAAA,cAAAjJ,EAAA,kBAAA+I,EAAA,OAGAJ,EAAAjR,UAAAwR,MAAA,WACA,OAAA1R,KAAAoR,IAGAD,EAAAjR,UAAAgR,QAAA,WACAlR,KAAAoR,IAAApR,KAAAoR,GAAA9G,UAGA6G,EAAAjR,UAAAmR,eAAA,WACA,IAAAD,EAAAO,SAAAC,cAAA,OAWA,OAltOA,SAAAR,EAAAS,GACA,QAAAvD,EAAA,EAAAlI,EAAA5G,OAAAsS,QAAAD,GAA+CvD,EAAAlI,EAAAxF,OAAgB0N,IAAA,CAC/D,IAAAyD,EAAA3L,EAAAkI,GACA0D,EAAAD,EAAA,GACAlJ,EAAAkJ,EAAA,GACAX,EAAAI,MAAAS,YAAAD,EAAAnJ,IAmsOAqJ,CAAAd,EAAA,CACAe,UAAA,SACAC,SAAA,QACAC,IAAA,IACAC,KAAA,IACAC,MAAA,OACAC,OAAA,OACAC,QAAA,eACAC,WAAA,shFAEAtB,GAGAD,EAlCA,GAuCAwB,GAEA,WACA,SAAAA,EAAAvB,GACApR,KAAAoR,KACApR,KAAA4S,OAAA,IAAAzB,GAmTA,OAhTAwB,EAAAzS,UAAA8Q,KAAA,WACAhR,KAAA4S,OAAAtB,OAAA,CACA9I,EAAA,EACA+I,EAAA,IAEA,IAAAsB,EAAAlB,SAAAmB,KAEA,WAAAC,iBAAA/S,KAAAoR,IAAAgB,SACApS,KAAAoR,GAAA4B,YAAAhT,KAAA4S,OAAAlB,SAEAmB,EAAAG,YAAAhT,KAAA4S,OAAAlB,UAIAiB,EAAAzS,UAAAgR,QAAA,WACAlR,KAAA4S,OAAA1B,WAGAyB,EAAAzS,UAAA4B,aAAA,SAAAe,GACA,IAAAoQ,EAAAjT,KAAAkT,uBAAArQ,GACA7B,EAAAhB,KAAAmT,qBAAAtQ,GAEA,OAAA7B,IAIAhB,KAAAoT,UAAAtS,MAAAd,KAAA,cAAAyK,OAAAzJ,IACAhB,KAAA4S,OAAAtB,OAAA2B,KAGAN,EAAAzS,UAAAsE,YAAA,SAAA3B,GACA,IAAA7B,EAAAhB,KAAAmT,qBAAAtQ,GAEA,OAAA7B,GAIAhB,KAAAoT,UAAAtS,MAAAd,KAAA,cAAAyK,OAAAzJ,KAGA2R,EAAAzS,UAAAyE,UAAA,SAAA9B,GACA,IAAA7B,EAAAhB,KAAAmT,qBAAAtQ,GAEA,OAAA7B,GAIAhB,KAAAoT,UAAAtS,MAAAd,KAAA,YAAAyK,OAAAzJ,KAGA2R,EAAAzS,UAAAiC,QAAA,SAAAU,GACA,IAAA7B,EAAAhB,KAAAmT,qBAAAtQ,GAEA,UAAA7B,EAAA,CAIA,IAAAoQ,EAAApQ,EAAA,GACAkP,EAAAlP,EAAA,GAEA,OAAA2Q,SAAA0B,eACArT,KAAAoT,UAAA,OAAAzB,SAAA0B,eAGArT,KAAAsT,SAAAlC,GACApR,KAAAoT,UAAA,QAAAhC,GACApR,KAAAoT,UAAA,QAAAhC,EAAAlB,KAGAyC,EAAAzS,UAAAgE,aAAA,SAAA9C,GACA,IAAAoH,EAAApH,EAAAoH,EACA+I,EAAAnQ,EAAAmQ,EACAlN,EAAAjD,EAAAiD,OACArD,EAAAhB,KAAAmT,qBAAA,CACA3K,IACA+I,MAGA,UAAAvQ,EAAA,CAIA,IAAAoQ,EAAApQ,EAAA,GACAkP,EAAAlP,EAAA,GACAkP,EAAA7P,EAAA,GAAwB6P,EAAA,CACxB7L,WAEArE,KAAAoT,UAAA,cAAAhC,EAAAlB,KAGAyC,EAAAzS,UAAAiD,WAAA,SAAAN,GACA,IAAAuO,EAAApR,KAAAuT,oBAAAvT,KAAAkT,uBAAArQ,IAEA,GAAAuO,EAAA,CAIA,OAAAA,EAAAoC,QAAAC,eACA,eACA,YACArC,EAAAsC,SAOA1T,KAAAoT,UAAA,WAAAhC,KAGAuB,EAAAzS,UAAA0D,QAAA,SAAA5C,GACA,IAAAoQ,EAAAO,SAAA0B,cAEA,GAAAjC,EAAA,CAIA,iBAAApQ,EAAAwB,KACA,OAAA4O,EAAAoC,QAAAC,eACA,eACA,YACA,IAAAE,EAAAvC,EAEA,wBAAAwC,SAAAD,EAAA1S,QAAA0S,EAAA9K,MACA,MAGA8K,EAAA9K,MAAAuI,EAAAvI,MAAAgL,MAAA,MACA,MAEA,QACAzC,EAAA0C,oBACA1C,EAAA2C,UAAA3C,EAAA2C,UAAAF,MAAA,OAOA7T,KAAAoT,UAAA,UAAAhC,EAAApQ,KAGA2R,EAAAzS,UAAA6D,MAAA,SAAA/C,GACA,IAAAoQ,EAAAO,SAAA0B,cAEAjC,GAIApR,KAAAoT,UAAA,QAAAhC,EAAApQ,IAGA2R,EAAAzS,UAAAoC,SAAA,SAAAlB,GACA,IAAAgQ,EAAAO,SAAA0B,cAEA,GAAAjC,QAAAhM,IAAAhE,EAAAqB,QAAA,CAMA,OAFAzC,KAAAoT,UAAA,WAAAhC,EAAAhQ,GAEAgQ,EAAAoC,QAAAC,eACA,eACA,YACArC,EAAAvI,OAAAmL,OAAAC,aAAA7S,EAAAqB,SACA,MAEA,QACA2O,EAAA2C,WAAAC,OAAAC,aAAA7S,EAAAqB,SAIAzC,KAAAoT,UAAA,QAAAhC,EAAAhQ,KAGAuR,EAAAzS,UAAA0C,OAAA,SAAAwD,GACA,IAQA8N,EARA1L,EAAApC,EAAAoC,EACA+I,EAAAnL,EAAAmL,EACAzO,EAAAsD,EAAAtD,OACAE,EAAAoD,EAAApD,OAMAoO,EALApR,KAAAuT,oBAAAvT,KAAAkT,uBAAA,CACA1K,IACA+I,OAKA,GAAAH,EAAA,CAIA,KAAAA,KAAA+C,eAAA,CACA,GAAAnU,KAAAoU,aAAAhD,GAAA,CACA8C,EAAA9C,EACA,MAGAA,IAAA+C,cAGAD,IACAA,EAAAvC,SAAAmB,MAGAoB,EAAAG,SAAA,CACA/B,KAAAxP,EACAuP,IAAArP,IAEAhD,KAAAoT,UAAA,QAAAhC,GACApR,KAAAoT,UAAA,SAAAhC,KAGAuB,EAAAzS,UAAAiT,qBAAA,SAAAtQ,GACA,IAAAoQ,EAAAjT,KAAAkT,uBAAArQ,GACAuO,EAAApR,KAAAuT,oBAAAN,GAEA,OAAA7B,EASA,CAAAA,EALA,CACAkD,QAAArB,EAAAzK,EACA+L,QAAAtB,EAAA1B,EACAiD,KAAAtN,SANA,MAWAyL,EAAAzS,UAAAgT,uBAAA,SAAA9M,GACA,IAAAoC,EAAApC,EAAAoC,EACA+I,EAAAnL,EAAAmL,EACAkD,EAAAvN,OAAAuN,YAEA,OACAjM,IAFAtB,OAAAwN,WAGAnD,IAAAkD,IAIA9B,EAAAzS,UAAAqT,oBAAA,SAAAnN,GACA,IAAAoC,EAAApC,EAAAoC,EACA+I,EAAAnL,EAAAmL,EACA,OAAAI,SAAAgD,iBAAAnM,EA5PA,EA4PA+I,EA5PA,IA+PAoB,EAAAzS,UAAAoT,SAAA,SAAAlC,GACAA,EAAAwD,OACAxD,EAAAwD,SAIAjC,EAAAzS,UAAAkT,UAAA,SAAAnS,EAAAmQ,EAAAlB,GAKA,IAAA9O,OAJA,IAAA8O,IACAA,EAAA,IAIA,IAAA2E,EAAA,CACAC,SAAA,EACAC,YAAA,GAGA,OAAA9T,GACA,YACA,eACA,gBACA,cACA,kBACA,gBACAG,EAAA,IAAA4T,WAAA/T,EAAAZ,EAAA,GAA+CwU,EAAA3E,IAC/C,MAEA,eACA,cACA,YACA9O,EAAA,IAAA6T,cAAAhU,EAAAZ,EAAA,GAAkDwU,EAAA3E,IAClD,MAEA,QACA9O,EAAA,IAAA8T,MAAAjU,EAAAZ,EAAA,GAA0CwU,EAAA3E,IAQ1C,OAJAhJ,OAAA,gBACA7F,QAAA8T,IAAA,QAAA/T,GAGAgQ,EAAAgE,cAAAhU,IAGAuR,EAAAzS,UAAAkU,aAAA,SAAAhD,GACA,OAAApR,KAAAqV,cAAAjE,IAAApR,KAAAsV,cAAAlE,IAGAuB,EAAAzS,UAAAoV,cAAA,SAAAlE,GACA,IAAAI,EAAAuB,iBAAA3B,GACA,wBAAAwC,SAAApC,EAAA+D,YAAAnE,EAAAoE,YAAApE,EAAAqE,aAGA9C,EAAAzS,UAAAmV,cAAA,SAAAjE,GACA,IAAAI,EAAAuB,iBAAA3B,GACA,wBAAAwC,SAAApC,EAAAkE,YAAAtE,EAAAuE,aAAAvE,EAAAwE,cAGAjD,EAtTA,GAyTAzT,GAEA,WACA,SAAAA,EAAAsR,EAAAY,GACApR,KAAAwQ,YACAxQ,KAAAoR,KACApR,KAAA0Q,QAAA7L,EACA7E,KAAA6V,eAAA,IAAAC,QA+CA,OA5CA5W,EAAAgB,UAAA6Q,MAAA,WACA/Q,KAAA+V,aACA/V,KAAAwQ,UAAA1J,aAGA5H,EAAAgB,UAAA+Q,KAAA,WACAjR,KAAAwQ,UAAAxJ,aACAhH,KAAAgW,iBAGA9W,EAAAgB,UAAA6V,WAAA,WACA,IAAArU,EAAA1B,KAEAA,KAAA0Q,QAAA/K,QAAA,SAAAX,GACAtD,EAAAmU,eAAAI,IAAAjR,EAAA,SAAA5D,GACA,IAAAiG,EAAArC,EAAA9D,YAAAQ,EAAAN,GAEAM,EAAA8O,UAAApJ,QAAAC,KAGA3F,EAAA0P,GAAAxJ,iBAAA5C,EAAA/C,UAAAP,EAAAmU,eAAA/E,IAAA9L,OAIA9F,EAAAgB,UAAA8V,cAAA,WACA,IAAAtU,EAAA1B,KAEAA,KAAA0Q,QAAA/K,QAAA,SAAAX,GACA,OAAAtD,EAAA0P,GAAAjK,oBAAAnC,EAAA/C,UAAAP,EAAAmU,eAAA/E,IAAA9L,OAIA9F,EAAAgB,UAAA6B,sBAAA,SAAAX,GACA,IAAA8U,EAAA9U,EAAA8U,QACAC,EAAA/U,EAAA+U,QACA/P,EAAAhF,EAAAgV,OACAR,EAAAxP,EAAAwP,aAEA,OACApN,EAAA0N,EAFA9P,EAAAqP,YAGAlE,EAAA4E,EAAAP,IAIA1W,EApDA,GAuDAmX,GAAA,IAAA9P,EAEA,SAAAtH,GAAAmS,EAAAZ,GAKA,YAJA,IAAAA,IACAA,EAAA6F,IAGA,IAAA9F,EAAAC,EAAA,IAAAmC,GAAAvB,mCC/zPe,SAAAkF,EAAAC,EAAAC,GACf,KAAAD,aAAAC,GACA,UAAAC,UAAA,qCAFA3X,EAAAC,EAAAC,EAAA,sBAAAsX,kCCAA,SAAAI,EAAAN,EAAAO,GACA,QAAAlW,EAAA,EAAiBA,EAAAkW,EAAA/V,OAAkBH,IAAA,CACnC,IAAAmW,EAAAD,EAAAlW,GACAmW,EAAAC,WAAAD,EAAAC,aAAA,EACAD,EAAAE,cAAA,EACA,UAAAF,MAAAG,UAAA,GACAvX,OAAAwX,eAAAZ,EAAAQ,EAAArU,IAAAqU,IAIe,SAAAK,EAAAT,EAAAU,EAAAC,GAGf,OAFAD,GAAAR,EAAAF,EAAAtW,UAAAgX,GACAC,GAAAT,EAAAF,EAAAW,GACAX,EAbA1X,EAAAC,EAAAC,EAAA,sBAAAiY,kCCAe,SAAAG,EAAAC,GAIf,OAHAD,EAAA5X,OAAAC,eAAAD,OAAA8X,eAAA,SAAAD,GACA,OAAAA,EAAA3X,WAAAF,OAAA8X,eAAAD,KAEAA,GAJAvY,EAAAC,EAAAC,EAAA,sBAAAoY,kCCAA,SAAAG,EAAAvK,GAA6U,OAA1OuK,EAA3E,oBAAAhM,QAAA,kBAAAA,OAAAiM,SAA2E,SAAAxK,GAAoC,cAAAA,GAA+B,SAAAA,GAAoC,OAAAA,GAAA,oBAAAzB,QAAAyB,EAAA/M,cAAAsL,QAAAyB,IAAAzB,OAAArL,UAAA,gBAAA8M,IAAmIA,GAE9T,SAAAyK,EAAAzK,GAWf,OATAyK,EADA,oBAAAlM,QAAA,WAAAgM,EAAAhM,OAAAiM,UACA,SAAAxK,GACA,OAAAuK,EAAAvK,IAGA,SAAAA,GACA,OAAAA,GAAA,oBAAAzB,QAAAyB,EAAA/M,cAAAsL,QAAAyB,IAAAzB,OAAArL,UAAA,SAAAqX,EAAAvK,KAIAA,GCXe,SAAA0K,EAAAC,EAAA9W,GACf,OAAAA,GAAsB,WAAP4W,EAAO5W,IAAA,oBAAAA,ECHP,SAAA8W,GACf,YAAAA,EACA,UAAAC,eAAA,6DAGA,OAAAD,EDESE,CAAqBF,GAH9B9W,EAJA/B,EAAAC,EAAAC,EAAA,sBAAA0Y,kCEAe,SAAAI,EAAAT,EAAAzX,GAMf,OALAkY,EAAAtY,OAAAC,gBAAA,SAAA4X,EAAAzX,GAEA,OADAyX,EAAA3X,UAAAE,EACAyX,IAGAA,EAAAzX,GCLe,SAAAmY,EAAAC,EAAAC,GACf,uBAAAA,GAAA,OAAAA,EACA,UAAAxB,UAAA,sDAGAuB,EAAA9X,UAAAV,OAAAW,OAAA8X,KAAA/X,UAAA,CACAD,YAAA,CACA4I,MAAAmP,EACAjB,UAAA,EACAD,cAAA,KAGAmB,GAAkBH,EAAcE,EAAAC,GAbhCnZ,EAAAC,EAAAC,EAAA,sBAAA+Y,kCCEA,IAAAlH,EAAArR,OAAAU,UAAAL,eACAqY,EAAA,IASA,SAAAC,KA4BA,SAAAC,EAAA9P,EAAAoE,EAAA2L,GACArY,KAAAsI,KACAtI,KAAA0M,UACA1M,KAAAqY,SAAA,EAeA,SAAAC,EAAAC,EAAAnX,EAAAkH,EAAAoE,EAAA2L,GACA,uBAAA/P,EACA,UAAAmO,UAAA,mCAGA,IAAA+B,EAAA,IAAAJ,EAAA9P,EAAAoE,GAAA6L,EAAAF,GACAI,EAAAP,IAAA9W,IAEA,OADAmX,EAAAG,QAAAD,GAAqFF,EAAAG,QAAAD,GAAAnQ,GAAuEiQ,EAAAG,QAAAD,GAAA,CAAAF,EAAAG,QAAAD,GAAAD,GAAvED,EAAAG,QAAAD,GAAAlT,KAAAiT,IAArFD,EAAAG,QAAAD,GAAAD,EAAAD,EAAAI,gBACAJ,EAWA,SAAAK,EAAAL,EAAAE,GACA,MAAAF,EAAAI,aAAAJ,EAAAG,QAAA,IAAAP,SAAmEI,EAAAG,QAAAD,GAWnE,SAAApZ,IACAW,KAAA0Y,QAAA,IAAAP,EACAnY,KAAA2Y,aAAA,EAtEAnZ,OAAAW,SACAgY,EAAAjY,UAAAV,OAAAW,OAAA,OAKA,IAAAgY,GAAAzY,YAAAwY,GAAA,IA2EA7Y,EAAAa,UAAA2Y,WAAA,WACA,IACAC,EACAlP,EAFAmP,EAAA,GAGA,OAAA/Y,KAAA2Y,aAAA,OAAAI,EAEA,IAAAnP,KAAAkP,EAAA9Y,KAAA0Y,QACA7H,EAAAhQ,KAAAiY,EAAAlP,IAAAmP,EAAAxT,KAAA2S,EAAAtO,EAAAiK,MAAA,GAAAjK,GAGA,OAAApK,OAAAwZ,sBACAD,EAAAtO,OAAAjL,OAAAwZ,sBAAAF,IAGAC,GAWA1Z,EAAAa,UAAAgF,UAAA,SAAA9D,GACA,IAAAqX,EAAAP,IAAA9W,IACA6X,EAAAjZ,KAAA0Y,QAAAD,GACA,IAAAQ,EAAA,SACA,GAAAA,EAAA3Q,GAAA,OAAA2Q,EAAA3Q,IAEA,QAAA7H,EAAA,EAAAyY,EAAAD,EAAArY,OAAAuY,EAAA,IAAAxZ,MAAAuZ,GAAyDzY,EAAAyY,EAAOzY,IAChE0Y,EAAA1Y,GAAAwY,EAAAxY,GAAA6H,GAGA,OAAA6Q,GAWA9Z,EAAAa,UAAAkZ,cAAA,SAAAhY,GACA,IAAAqX,EAAAP,IAAA9W,IACA8D,EAAAlF,KAAA0Y,QAAAD,GACA,OAAAvT,EACAA,EAAAoD,GAAA,EACApD,EAAAtE,OAFA,GAaAvB,EAAAa,UAAAmZ,KAAA,SAAAjY,EAAAkY,EAAAC,EAAAC,EAAAC,EAAAC,GACA,IAAAjB,EAAAP,IAAA9W,IACA,IAAApB,KAAA0Y,QAAAD,GAAA,SACA,IAEAkB,EACAlZ,EAHAyE,EAAAlF,KAAA0Y,QAAAD,GACApO,EAAA1J,UAAAC,OAIA,GAAAsE,EAAAoD,GAAA,CAGA,OAFApD,EAAAmT,MAAArY,KAAA4Z,eAAAxY,EAAA8D,EAAAoD,QAAAlD,GAAA,GAEAiF,GACA,OACA,OAAAnF,EAAAoD,GAAAzH,KAAAqE,EAAAwH,UAAA,EAEA,OACA,OAAAxH,EAAAoD,GAAAzH,KAAAqE,EAAAwH,QAAA4M,IAAA,EAEA,OACA,OAAApU,EAAAoD,GAAAzH,KAAAqE,EAAAwH,QAAA4M,EAAAC,IAAA,EAEA,OACA,OAAArU,EAAAoD,GAAAzH,KAAAqE,EAAAwH,QAAA4M,EAAAC,EAAAC,IAAA,EAEA,OACA,OAAAtU,EAAAoD,GAAAzH,KAAAqE,EAAAwH,QAAA4M,EAAAC,EAAAC,EAAAC,IAAA,EAEA,OACA,OAAAvU,EAAAoD,GAAAzH,KAAAqE,EAAAwH,QAAA4M,EAAAC,EAAAC,EAAAC,EAAAC,IAAA,EAGA,IAAAjZ,EAAA,EAAAkZ,EAAA,IAAAha,MAAA0K,EAAA,GAA0C5J,EAAA4J,EAAS5J,IACnDkZ,EAAAlZ,EAAA,GAAAE,UAAAF,GAGAyE,EAAAoD,GAAAxH,MAAAoE,EAAAwH,QAAAiN,OACG,CACH,IACAE,EADAjZ,EAAAsE,EAAAtE,OAGA,IAAAH,EAAA,EAAeA,EAAAG,EAAYH,IAG3B,OAFAyE,EAAAzE,GAAA4X,MAAArY,KAAA4Z,eAAAxY,EAAA8D,EAAAzE,GAAA6H,QAAAlD,GAAA,GAEAiF,GACA,OACAnF,EAAAzE,GAAA6H,GAAAzH,KAAAqE,EAAAzE,GAAAiM,SACA,MAEA,OACAxH,EAAAzE,GAAA6H,GAAAzH,KAAAqE,EAAAzE,GAAAiM,QAAA4M,GACA,MAEA,OACApU,EAAAzE,GAAA6H,GAAAzH,KAAAqE,EAAAzE,GAAAiM,QAAA4M,EAAAC,GACA,MAEA,OACArU,EAAAzE,GAAA6H,GAAAzH,KAAAqE,EAAAzE,GAAAiM,QAAA4M,EAAAC,EAAAC,GACA,MAEA,QACA,IAAAG,EAAA,IAAAE,EAAA,EAAAF,EAAA,IAAAha,MAAA0K,EAAA,GAA2DwP,EAAAxP,EAASwP,IACpEF,EAAAE,EAAA,GAAAlZ,UAAAkZ,GAEA3U,EAAAzE,GAAA6H,GAAAxH,MAAAoE,EAAAzE,GAAAiM,QAAAiN,IAKA,UAaAta,EAAAa,UAAAmF,GAAA,SAAAjE,EAAAkH,EAAAoE,GACA,OAAA4L,EAAAtY,KAAAoB,EAAAkH,EAAAoE,GAAA,IAaArN,EAAAa,UAAAmY,KAAA,SAAAjX,EAAAkH,EAAAoE,GACA,OAAA4L,EAAAtY,KAAAoB,EAAAkH,EAAAoE,GAAA,IAcArN,EAAAa,UAAA0Z,eAAA,SAAAxY,EAAAkH,EAAAoE,EAAA2L,GACA,IAAAI,EAAAP,IAAA9W,IACA,IAAApB,KAAA0Y,QAAAD,GAAA,OAAAzY,KAEA,IAAAsI,EAEA,OADAsQ,EAAA5Y,KAAAyY,GACAzY,KAGA,IAAAkF,EAAAlF,KAAA0Y,QAAAD,GAEA,GAAAvT,EAAAoD,GACApD,EAAAoD,QAAA+P,IAAAnT,EAAAmT,MAAA3L,GAAAxH,EAAAwH,aACAkM,EAAA5Y,KAAAyY,OAEG,CACH,QAAAhY,EAAA,EAAAqY,EAAA,GAAAlY,EAAAsE,EAAAtE,OAA2DH,EAAAG,EAAYH,KACvEyE,EAAAzE,GAAA6H,QAAA+P,IAAAnT,EAAAzE,GAAA4X,MAAA3L,GAAAxH,EAAAzE,GAAAiM,cACAoM,EAAAvT,KAAAL,EAAAzE,IAOAqY,EAAAlY,OAAAZ,KAAA0Y,QAAAD,GAAA,IAAAK,EAAAlY,OAAAkY,EAAA,GAAAA,EAAoFF,EAAA5Y,KAAAyY,GAGpF,OAAAzY,MAWAX,EAAAa,UAAA4Z,mBAAA,SAAA1Y,GACA,IAAAqX,EAUA,OARArX,GACAqX,EAAAP,IAAA9W,IACApB,KAAA0Y,QAAAD,IAAAG,EAAA5Y,KAAAyY,KAEAzY,KAAA0Y,QAAA,IAAAP,EACAnY,KAAA2Y,aAAA,GAGA3Y,MAMAX,EAAAa,UAAAiF,IAAA9F,EAAAa,UAAA0Z,eACAva,EAAAa,UAAAoY,YAAAjZ,EAAAa,UAAAmF,GAIAhG,EAAA0a,SAAA7B,EAIA7Y,iBAKA2a,EAAAC,QAAA5a,gCCtVe,SAAA6a,EAAAC,GACf,OCJe,SAAAA,GACf,GAAAxa,MAAA+F,QAAAyU,GAAA,CACA,QAAA1Z,EAAA,EAAA2Z,EAAA,IAAAza,MAAAwa,EAAAvZ,QAAiDH,EAAA0Z,EAAAvZ,OAAgBH,IACjE2Z,EAAA3Z,GAAA0Z,EAAA1Z,GAGA,OAAA2Z,GDFSC,CAAiBF,IEJX,SAAAG,GACf,GAAA/O,OAAAiM,YAAAhY,OAAA8a,IAAA,uBAAA9a,OAAAU,UAAAwJ,SAAA7I,KAAAyZ,GAAA,OAAA3a,MAAA4a,KAAAD,GFGmCE,CAAeL,IGJnC,WACf,UAAA1D,UAAA,mDHG2DgE,GAJ3D3b,EAAAC,EAAAC,EAAA,sBAAAkb,mCIAe,SAAAQ,EAAA1N,EAAAzK,EAAAsG,GAYf,OAXAtG,KAAAyK,EACAxN,OAAAwX,eAAAhK,EAAAzK,EAAA,CACAsG,QACAgO,YAAA,EACAC,cAAA,EACAC,UAAA,IAGA/J,EAAAzK,GAAAsG,EAGAmE,ECXe,SAAA2N,EAAAvE,GACf,QAAA3V,EAAA,EAAiBA,EAAAE,UAAAC,OAAsBH,IAAA,CACvC,IAAAiN,EAAA,MAAA/M,UAAAF,GAAAE,UAAAF,GAAA,GACAma,EAAApb,OAAAqI,KAAA6F,GAEA,oBAAAlO,OAAAwZ,wBACA4B,IAAAnQ,OAAAjL,OAAAwZ,sBAAAtL,GAAAmN,OAAA,SAAAC,GACA,OAAAtb,OAAAub,yBAAArN,EAAAoN,GAAAjE,eAIA+D,EAAAjV,QAAA,SAAApD,GACMmY,EAActE,EAAA7T,EAAAmL,EAAAnL,MAIpB,OAAA6T,EAjBAtX,EAAAC,EAAAC,EAAA,sBAAA2b","file":"static/js/2.4b411639.chunk.js","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return _extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return _assign.apply(this, arguments);\n};\n\nvar ActionsName;\n\n(function (ActionsName) {\n  ActionsName[\"BASE\"] = \"[Action] Base\";\n  ActionsName[\"MOVE_TO\"] = \"[Action] Move To\";\n  ActionsName[\"MOUSE_DOWN_TO\"] = \"[Action] MouseDown To\";\n  ActionsName[\"MOUSE_UP_TO\"] = \"[Action] MouseUp To\";\n  ActionsName[\"CLICK_TO\"] = \"[Action] Click To\";\n  ActionsName[\"RIGHT_CLICK_TO\"] = \"[Action] Right Click To\";\n  ActionsName[\"DBL_CLICK_TO\"] = \"[Action] Double Click To\";\n  ActionsName[\"KEYPRESS\"] = \"[Action] Keypress\";\n  ActionsName[\"KEYDOWN\"] = \"[Action] Keydown\";\n  ActionsName[\"KEYUP\"] = \"[Action] Keyup\";\n  ActionsName[\"SCROLL_BY\"] = \"[Action] Scroll By\";\n})(ActionsName || (ActionsName = {}));\n\nvar BaseAction =\n/** @class */\nfunction () {\n  function BaseAction(payload) {\n    if (payload === void 0) {\n      payload = {};\n    }\n\n    this.payload = payload;\n    this.type = BaseAction.type;\n  }\n\n  BaseAction.handleEvent = function (host, event) {\n    console.warn(\"You have to implement a static method handleEvent for \" + this.type + \" action\");\n    return {};\n  };\n\n  BaseAction.type = ActionsName.BASE;\n  return BaseAction;\n}();\n\nvar MoveToAction =\n/** @class */\nfunction (_super) {\n  __extends(MoveToAction, _super);\n\n  function MoveToAction(payload) {\n    var _this = _super.call(this) || this;\n\n    _this.payload = payload;\n    _this.type = MoveToAction.type;\n    return _this;\n  }\n\n  MoveToAction.prototype.performEvent = function (dom, stack) {\n    dom.moveCursorTo(this.payload);\n  };\n\n  MoveToAction.handleEvent = function (host, event) {\n    var payload = host.getRelativeCoordinate(event);\n    return new MoveToAction(payload);\n  };\n\n  MoveToAction.type = ActionsName.MOVE_TO;\n  MoveToAction.eventName = 'mousemove';\n  return MoveToAction;\n}(BaseAction);\n\nvar ClickToAction =\n/** @class */\nfunction (_super) {\n  __extends(ClickToAction, _super);\n\n  function ClickToAction(payload) {\n    var _this = _super.call(this) || this;\n\n    _this.payload = payload;\n    _this.type = ClickToAction.type;\n    return _this;\n  }\n\n  ClickToAction.prototype.performEvent = function (dom, stack) {\n    dom.clickTo(this.payload);\n  };\n\n  ClickToAction.handleEvent = function (host, event) {\n    var payload = host.getRelativeCoordinate(event);\n    return new ClickToAction(payload);\n  };\n\n  ClickToAction.type = ActionsName.CLICK_TO;\n  ClickToAction.eventName = 'click';\n  return ClickToAction;\n}(BaseAction);\n\nvar KeypressAction =\n/** @class */\nfunction (_super) {\n  __extends(KeypressAction, _super);\n\n  function KeypressAction(payload) {\n    var _this = _super.call(this) || this;\n\n    _this.payload = payload;\n    _this.type = KeypressAction.type;\n    return _this;\n  }\n\n  KeypressAction.prototype.performEvent = function (dom, stack) {\n    dom.keypress(this.payload);\n  };\n\n  KeypressAction.handleEvent = function (host, event) {\n    return new KeypressAction({\n      key: event.key,\n      code: event.code,\n      keyCode: event.keyCode\n    });\n  };\n\n  KeypressAction.type = ActionsName.KEYPRESS;\n  KeypressAction.eventName = 'keypress';\n  return KeypressAction;\n}(BaseAction);\n\nvar ScrollByAction =\n/** @class */\nfunction (_super) {\n  __extends(ScrollByAction, _super);\n\n  function ScrollByAction(payload) {\n    var _this = _super.call(this) || this;\n\n    _this.payload = payload;\n    _this.type = ScrollByAction.type;\n    return _this;\n  }\n\n  ScrollByAction.prototype.performEvent = function (dom, stack) {\n    dom.scroll(this.payload);\n  };\n\n  ScrollByAction.handleEvent = function (host, event) {\n    var coordinates = host.getRelativeCoordinate(event);\n    return new ScrollByAction(_assign({}, coordinates, {\n      deltaX: event.shiftKey ? event.deltaY : 0,\n      deltaY: event.shiftKey ? 0 : event.deltaY\n    }));\n  };\n\n  ScrollByAction.type = ActionsName.SCROLL_BY;\n  ScrollByAction.eventName = 'mousewheel';\n  return ScrollByAction;\n}(BaseAction);\n\nvar DblClickToAction =\n/** @class */\nfunction (_super) {\n  __extends(DblClickToAction, _super);\n\n  function DblClickToAction(payload) {\n    var _this = _super.call(this) || this;\n\n    _this.payload = payload;\n    _this.type = DblClickToAction.type;\n    return _this;\n  }\n\n  DblClickToAction.prototype.performEvent = function (dom, stack) {\n    dom.dblClickTo(this.payload);\n  };\n\n  DblClickToAction.handleEvent = function (host, event) {\n    var payload = host.getRelativeCoordinate(event);\n    return new DblClickToAction(payload);\n  };\n\n  DblClickToAction.type = ActionsName.DBL_CLICK_TO;\n  DblClickToAction.eventName = 'dblclick';\n  return DblClickToAction;\n}(BaseAction);\n\nfunction css(el, styles) {\n  for (var _i = 0, _a = Object.entries(styles); _i < _a.length; _i++) {\n    var _b = _a[_i],\n        prop = _b[0],\n        value = _b[1];\n    el.style.setProperty(prop, value);\n  }\n}\n\nfunction pick(src, fields) {\n  if (fields === void 0) {\n    fields = [];\n  }\n\n  return fields.reduce(function (result, field) {\n    result[field] = src[field];\n    return result;\n  }, {});\n}\n\nvar DEBUG_FLAG = 'preoccupydebug';\n\nvar KeydownAction =\n/** @class */\nfunction (_super) {\n  __extends(KeydownAction, _super);\n\n  function KeydownAction(payload) {\n    var _this = _super.call(this) || this;\n\n    _this.payload = payload;\n    _this.type = KeydownAction.type;\n    return _this;\n  }\n\n  KeydownAction.prototype.performEvent = function (dom, stack) {\n    dom.keydown(this.payload);\n  };\n\n  KeydownAction.handleEvent = function (host, event) {\n    var eventData = pick(event, ['which', 'key', 'code', 'ctrlKey', 'keyCode', 'metaKey', 'shiftKey', 'type']);\n    return new KeydownAction(eventData);\n  };\n\n  KeydownAction.type = ActionsName.KEYDOWN;\n  KeydownAction.eventName = 'keydown';\n  return KeydownAction;\n}(BaseAction);\n\nvar KeyupAction =\n/** @class */\nfunction (_super) {\n  __extends(KeyupAction, _super);\n\n  function KeyupAction(payload) {\n    var _this = _super.call(this) || this;\n\n    _this.payload = payload;\n    _this.type = KeyupAction.type;\n    return _this;\n  }\n\n  KeyupAction.prototype.performEvent = function (dom, stack) {\n    dom.keyup(this.payload);\n  };\n\n  KeyupAction.handleEvent = function (host, event) {\n    var eventData = pick(event, ['which', 'key', 'code', 'ctrlKey', 'keyCode', 'metaKey', 'shiftKey', 'type']);\n    return new KeyupAction(eventData);\n  };\n\n  KeyupAction.type = ActionsName.KEYUP;\n  KeyupAction.eventName = 'keyup';\n  return KeyupAction;\n}(BaseAction);\n\nvar RightClickToAction =\n/** @class */\nfunction (_super) {\n  __extends(RightClickToAction, _super);\n\n  function RightClickToAction(payload) {\n    var _this = _super.call(this) || this;\n\n    _this.payload = payload;\n    _this.type = RightClickToAction.type;\n    return _this;\n  }\n\n  RightClickToAction.prototype.performEvent = function (dom, stack) {\n    dom.rightClickTo(this.payload);\n  };\n\n  RightClickToAction.handleEvent = function (host, event) {\n    var e = event;\n    event.preventDefault();\n\n    var payload = _assign({}, host.getRelativeCoordinate(e), {\n      button: e.button\n    });\n\n    return new RightClickToAction(payload);\n  };\n\n  RightClickToAction.type = ActionsName.RIGHT_CLICK_TO;\n  RightClickToAction.eventName = 'contextmenu';\n  return RightClickToAction;\n}(BaseAction);\n\nvar MouseDownToAction =\n/** @class */\nfunction (_super) {\n  __extends(MouseDownToAction, _super);\n\n  function MouseDownToAction(payload) {\n    var _this = _super.call(this) || this;\n\n    _this.payload = payload;\n    _this.type = MouseDownToAction.type;\n    return _this;\n  }\n\n  MouseDownToAction.prototype.performEvent = function (dom, stack) {\n    dom.mouseDownTo(this.payload);\n  };\n\n  MouseDownToAction.handleEvent = function (host, event) {\n    var payload = host.getRelativeCoordinate(event);\n    return new MouseDownToAction(payload);\n  };\n\n  MouseDownToAction.type = ActionsName.MOUSE_DOWN_TO;\n  MouseDownToAction.eventName = 'mousedown';\n  return MouseDownToAction;\n}(BaseAction);\n\nvar MouseUpToAction =\n/** @class */\nfunction (_super) {\n  __extends(MouseUpToAction, _super);\n\n  function MouseUpToAction(payload) {\n    var _this = _super.call(this) || this;\n\n    _this.payload = payload;\n    _this.type = MouseUpToAction.type;\n    return _this;\n  }\n\n  MouseUpToAction.prototype.performEvent = function (dom, stack) {\n    dom.mouseUpTo(this.payload);\n  };\n\n  MouseUpToAction.handleEvent = function (host, event) {\n    var payload = host.getRelativeCoordinate(event);\n    return new MouseUpToAction(payload);\n  };\n\n  MouseUpToAction.type = ActionsName.MOUSE_UP_TO;\n  MouseUpToAction.eventName = 'mouseup';\n  return MouseUpToAction;\n}(BaseAction);\n\nvar actionMap = new Map([MoveToAction, ClickToAction, KeydownAction, KeypressAction, KeyupAction, MoveToAction, ScrollByAction, DblClickToAction, RightClickToAction, MouseDownToAction, MouseUpToAction].map(function (Action) {\n  return [Action.type, Action];\n}));\nvar TransportEvents;\n\n(function (TransportEvents) {\n  TransportEvents[TransportEvents[\"connect\"] = 0] = \"connect\";\n  TransportEvents[TransportEvents[\"disconnect\"] = 1] = \"disconnect\";\n  TransportEvents[TransportEvents[\"action\"] = 2] = \"action\";\n})(TransportEvents || (TransportEvents = {}));\n\nvar EventEmitter =\n/** @class */\nfunction () {\n  function EventEmitter() {\n    this.listeners = {};\n  }\n\n  EventEmitter.prototype.off = function (type) {\n    if (type === undefined) {\n      this.listeners = {};\n      return;\n    }\n\n    this.listeners[type] = [];\n  };\n\n  EventEmitter.prototype.on = function (type, callback) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n\n    this.listeners[type].push(callback);\n  };\n\n  EventEmitter.prototype.trigger = function (type, detail) {\n    if (Array.isArray(this.listeners[type])) {\n      this.listeners[type].forEach(function (callback) {\n        return callback({\n          type: type,\n          detail: detail\n        });\n      });\n    }\n  };\n\n  return EventEmitter;\n}();\n\nvar Message =\n/** @class */\nfunction () {\n  function Message(type, data, hash) {\n    this.type = type;\n    this.data = data;\n    this.hash = hash || Math.random() * 10e6 + '';\n  }\n\n  Message.prototype.serialize = function () {\n    return JSON.stringify(this.data);\n  };\n\n  Message.parse = function (src) {\n    var _a = src.split('|'),\n        _prefix = _a[0],\n        type = _a[1],\n        hash = _a[2],\n        dataSrc = _a[3];\n\n    return new Message(type, JSON.parse(dataSrc), hash);\n  };\n\n  return Message;\n}();\n\nvar LocalTransport =\n/** @class */\nfunction (_super) {\n  __extends(LocalTransport, _super);\n\n  function LocalTransport(preifx, stackSize) {\n    if (preifx === void 0) {\n      preifx = 'prefix';\n    }\n\n    if (stackSize === void 0) {\n      stackSize = 10;\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.preifx = preifx;\n    _this.stackSize = stackSize;\n    _this.connected = false;\n    _this.publishedMessages = [];\n    _this.storage = localStorage;\n    return _this;\n  }\n\n  LocalTransport.prototype.handshake = function () {\n    if (this.connected) {\n      this.trigger(TransportEvents.connect);\n    } else {\n      this.connect();\n    }\n  };\n\n  LocalTransport.prototype.disconnect = function () {\n    this.cleanUp();\n    window.removeEventListener('storage', this);\n    this.off();\n    this.connected = false;\n  };\n\n  LocalTransport.prototype.publish = function (action) {\n    var message = new Message('action', action);\n    this.publishedMessages.push(message);\n    this.storage.setItem(this.preifx + \"|\" + message.type + \"|\" + message.hash, message.serialize());\n\n    if (this.publishedMessages.length > this.stackSize) {\n      var messageToDelete = this.publishedMessages.shift();\n\n      if (messageToDelete) {\n        this.storage.removeItem(this.preifx + \"|\" + messageToDelete.type + \"|\" + messageToDelete.hash);\n      }\n    }\n  };\n\n  LocalTransport.prototype.handleEvent = function (event) {\n    switch (event.type) {\n      case 'storage':\n        this.onStorageMessage(event);\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  LocalTransport.prototype.connect = function () {\n    window.addEventListener('storage', this);\n    this.connected = true;\n    this.trigger(TransportEvents.connect);\n  };\n\n  LocalTransport.prototype.cleanUp = function () {\n    var _this = this;\n\n    Object.keys(localStorage).forEach(function (key) {\n      if (key.startsWith(_this.preifx)) {\n        localStorage.removeItem(key);\n      }\n    });\n  };\n\n  LocalTransport.prototype.onStorageMessage = function (_a) {\n    var key = _a.key,\n        newValue = _a.newValue;\n\n    if (key && newValue && key.startsWith(this.preifx)) {\n      var message = Message.parse(key + '|' + newValue);\n\n      if (this.isExternalMessage(message)) {\n        this.trigger(TransportEvents.action, message);\n      }\n    }\n  };\n\n  LocalTransport.prototype.isExternalMessage = function (message) {\n    return !this.publishedMessages.find(function (ownMessage) {\n      return ownMessage.hash === message.hash;\n    });\n  };\n\n  return LocalTransport;\n}(EventEmitter);\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar errorObject = {\n  e: {}\n};\n/** PURE_IMPORTS_START _errorObject PURE_IMPORTS_END */\n\nvar tryCatchTarget;\n\nfunction tryCatcher() {\n  try {\n    return tryCatchTarget.apply(this, arguments);\n  } catch (e) {\n    errorObject.e = e;\n    return errorObject;\n  }\n}\n\nfunction tryCatch(fn) {\n  tryCatchTarget = fn;\n  return tryCatcher;\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar _enable_super_gross_mode_that_will_cause_bad_things = false;\nvar config = {\n  Promise: undefined,\n\n  set useDeprecatedSynchronousErrorHandling(value) {\n    if (value) {\n      var error =\n      /*@__PURE__*/\n      new Error();\n      /*@__PURE__*/\n\n      console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \\n' + error.stack);\n    } else if (_enable_super_gross_mode_that_will_cause_bad_things) {\n      /*@__PURE__*/\n      console.log('RxJS: Back to a better error behavior. Thank you. <3');\n    }\n\n    _enable_super_gross_mode_that_will_cause_bad_things = value;\n  },\n\n  get useDeprecatedSynchronousErrorHandling() {\n    return _enable_super_gross_mode_that_will_cause_bad_things;\n  }\n\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\nfunction hostReportError(err) {\n  setTimeout(function () {\n    throw err;\n  });\n}\n/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */\n\n\nvar empty = {\n  closed: true,\n  next: function next(value) {},\n  error: function error(err) {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      throw err;\n    } else {\n      hostReportError(err);\n    }\n  },\n  complete: function complete() {}\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\nvar isArray = Array.isArray || function (x) {\n  return x && typeof x.length === 'number';\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction isObject(x) {\n  return x != null && typeof x === 'object';\n}\n/** PURE_IMPORTS_START tslib PURE_IMPORTS_END */\n\n\nvar UnsubscriptionError =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(UnsubscriptionError, _super);\n\n  function UnsubscriptionError(errors) {\n    var _this = _super.call(this, errors ? errors.length + \" errors occurred during unsubscription:\\n  \" + errors.map(function (err, i) {\n      return i + 1 + \") \" + err.toString();\n    }).join('\\n  ') : '') || this;\n\n    _this.errors = errors;\n    _this.name = 'UnsubscriptionError';\n    Object.setPrototypeOf(_this, UnsubscriptionError.prototype);\n    return _this;\n  }\n\n  return UnsubscriptionError;\n}(Error);\n/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_tryCatch,_util_errorObject,_util_UnsubscriptionError PURE_IMPORTS_END */\n\n\nvar Subscription =\n/*@__PURE__*/\nfunction () {\n  function Subscription(unsubscribe) {\n    this.closed = false;\n    this._parent = null;\n    this._parents = null;\n    this._subscriptions = null;\n\n    if (unsubscribe) {\n      this._unsubscribe = unsubscribe;\n    }\n  }\n\n  Subscription.prototype.unsubscribe = function () {\n    var hasErrors = false;\n    var errors;\n\n    if (this.closed) {\n      return;\n    }\n\n    var _a = this,\n        _parent = _a._parent,\n        _parents = _a._parents,\n        _unsubscribe = _a._unsubscribe,\n        _subscriptions = _a._subscriptions;\n\n    this.closed = true;\n    this._parent = null;\n    this._parents = null;\n    this._subscriptions = null;\n    var index = -1;\n    var len = _parents ? _parents.length : 0;\n\n    while (_parent) {\n      _parent.remove(this);\n\n      _parent = ++index < len && _parents[index] || null;\n    }\n\n    if (isFunction(_unsubscribe)) {\n      var trial = tryCatch(_unsubscribe).call(this);\n\n      if (trial === errorObject) {\n        hasErrors = true;\n        errors = errors || (errorObject.e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]);\n      }\n    }\n\n    if (isArray(_subscriptions)) {\n      index = -1;\n      len = _subscriptions.length;\n\n      while (++index < len) {\n        var sub = _subscriptions[index];\n\n        if (isObject(sub)) {\n          var trial = tryCatch(sub.unsubscribe).call(sub);\n\n          if (trial === errorObject) {\n            hasErrors = true;\n            errors = errors || [];\n            var err = errorObject.e;\n\n            if (err instanceof UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n    }\n\n    if (hasErrors) {\n      throw new UnsubscriptionError(errors);\n    }\n  };\n\n  Subscription.prototype.add = function (teardown) {\n    if (!teardown || teardown === Subscription.EMPTY) {\n      return Subscription.EMPTY;\n    }\n\n    if (teardown === this) {\n      return this;\n    }\n\n    var subscription = teardown;\n\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(teardown);\n\n      case 'object':\n        if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (typeof subscription._addParent !== 'function') {\n          var tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n\n        break;\n\n      default:\n        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n    }\n\n    var subscriptions = this._subscriptions || (this._subscriptions = []);\n    subscriptions.push(subscription);\n\n    subscription._addParent(this);\n\n    return subscription;\n  };\n\n  Subscription.prototype.remove = function (subscription) {\n    var subscriptions = this._subscriptions;\n\n    if (subscriptions) {\n      var subscriptionIndex = subscriptions.indexOf(subscription);\n\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  };\n\n  Subscription.prototype._addParent = function (parent) {\n    var _a = this,\n        _parent = _a._parent,\n        _parents = _a._parents;\n\n    if (!_parent || _parent === parent) {\n      this._parent = parent;\n    } else if (!_parents) {\n      this._parents = [parent];\n    } else if (_parents.indexOf(parent) === -1) {\n      _parents.push(parent);\n    }\n  };\n\n  Subscription.EMPTY = function (empty) {\n    empty.closed = true;\n    return empty;\n  }(new Subscription());\n\n  return Subscription;\n}();\n\nfunction flattenUnsubscriptionErrors(errors) {\n  return errors.reduce(function (errs, err) {\n    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);\n  }, []);\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar rxSubscriber = typeof Symbol === 'function' && typeof Symbol.for === 'function' ?\n/*@__PURE__*/\nSymbol.for('rxSubscriber') : '@@rxSubscriber';\n/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */\n\nvar Subscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(Subscriber, _super);\n\n  function Subscriber(destinationOrNext, error, complete) {\n    var _this = _super.call(this) || this;\n\n    _this.syncErrorValue = null;\n    _this.syncErrorThrown = false;\n    _this.syncErrorThrowable = false;\n    _this.isStopped = false;\n\n    switch (arguments.length) {\n      case 0:\n        _this.destination = empty;\n        break;\n\n      case 1:\n        if (!destinationOrNext) {\n          _this.destination = empty;\n          break;\n        }\n\n        if (typeof destinationOrNext === 'object') {\n          if (isTrustedSubscriber(destinationOrNext)) {\n            var trustedSubscriber = destinationOrNext[rxSubscriber]();\n            _this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;\n            _this.destination = trustedSubscriber;\n            trustedSubscriber.add(_this);\n          } else {\n            _this.syncErrorThrowable = true;\n            _this.destination = new SafeSubscriber(_this, destinationOrNext);\n          }\n\n          break;\n        }\n\n      default:\n        _this.syncErrorThrowable = true;\n        _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);\n        break;\n    }\n\n    return _this;\n  }\n\n  Subscriber.prototype[rxSubscriber] = function () {\n    return this;\n  };\n\n  Subscriber.create = function (next, error, complete) {\n    var subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  };\n\n  Subscriber.prototype.next = function (value) {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  };\n\n  Subscriber.prototype.error = function (err) {\n    if (!this.isStopped) {\n      this.isStopped = true;\n\n      this._error(err);\n    }\n  };\n\n  Subscriber.prototype.complete = function () {\n    if (!this.isStopped) {\n      this.isStopped = true;\n\n      this._complete();\n    }\n  };\n\n  Subscriber.prototype.unsubscribe = function () {\n    if (this.closed) {\n      return;\n    }\n\n    this.isStopped = true;\n\n    _super.prototype.unsubscribe.call(this);\n  };\n\n  Subscriber.prototype._next = function (value) {\n    this.destination.next(value);\n  };\n\n  Subscriber.prototype._error = function (err) {\n    this.destination.error(err);\n    this.unsubscribe();\n  };\n\n  Subscriber.prototype._complete = function () {\n    this.destination.complete();\n    this.unsubscribe();\n  };\n\n  Subscriber.prototype._unsubscribeAndRecycle = function () {\n    var _a = this,\n        _parent = _a._parent,\n        _parents = _a._parents;\n\n    this._parent = null;\n    this._parents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parent = _parent;\n    this._parents = _parents;\n    return this;\n  };\n\n  return Subscriber;\n}(Subscription);\n\nvar SafeSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(SafeSubscriber, _super);\n\n  function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\n    var _this = _super.call(this) || this;\n\n    _this._parentSubscriber = _parentSubscriber;\n    var next;\n    var context = _this;\n\n    if (isFunction(observerOrNext)) {\n      next = observerOrNext;\n    } else if (observerOrNext) {\n      next = observerOrNext.next;\n      error = observerOrNext.error;\n      complete = observerOrNext.complete;\n\n      if (observerOrNext !== empty) {\n        context = Object.create(observerOrNext);\n\n        if (isFunction(context.unsubscribe)) {\n          _this.add(context.unsubscribe.bind(context));\n        }\n\n        context.unsubscribe = _this.unsubscribe.bind(_this);\n      }\n    }\n\n    _this._context = context;\n    _this._next = next;\n    _this._error = error;\n    _this._complete = complete;\n    return _this;\n  }\n\n  SafeSubscriber.prototype.next = function (value) {\n    if (!this.isStopped && this._next) {\n      var _parentSubscriber = this._parentSubscriber;\n\n      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.error = function (err) {\n    if (!this.isStopped) {\n      var _parentSubscriber = this._parentSubscriber;\n      var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;\n\n      if (this._error) {\n        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n\n        if (useDeprecatedSynchronousErrorHandling) {\n          throw err;\n        }\n\n        hostReportError(err);\n      } else {\n        if (useDeprecatedSynchronousErrorHandling) {\n          _parentSubscriber.syncErrorValue = err;\n          _parentSubscriber.syncErrorThrown = true;\n        } else {\n          hostReportError(err);\n        }\n\n        this.unsubscribe();\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.complete = function () {\n    var _this = this;\n\n    if (!this.isStopped) {\n      var _parentSubscriber = this._parentSubscriber;\n\n      if (this._complete) {\n        var wrappedComplete = function wrappedComplete() {\n          return _this._complete.call(_this._context);\n        };\n\n        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        throw err;\n      } else {\n        hostReportError(err);\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n    if (!config.useDeprecatedSynchronousErrorHandling) {\n      throw new Error('bad call');\n    }\n\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        parent.syncErrorValue = err;\n        parent.syncErrorThrown = true;\n        return true;\n      } else {\n        hostReportError(err);\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  SafeSubscriber.prototype._unsubscribe = function () {\n    var _parentSubscriber = this._parentSubscriber;\n    this._context = null;\n    this._parentSubscriber = null;\n\n    _parentSubscriber.unsubscribe();\n  };\n\n  return SafeSubscriber;\n}(Subscriber);\n\nfunction isTrustedSubscriber(obj) {\n  return obj instanceof Subscriber || 'syncErrorThrowable' in obj && obj[rxSubscriber];\n}\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nvar OuterSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(OuterSubscriber, _super);\n\n  function OuterSubscriber() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.destination.next(innerValue);\n  };\n\n  OuterSubscriber.prototype.notifyError = function (error, innerSub) {\n    this.destination.error(error);\n  };\n\n  OuterSubscriber.prototype.notifyComplete = function (innerSub) {\n    this.destination.complete();\n  };\n\n  return OuterSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nvar InnerSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(InnerSubscriber, _super);\n\n  function InnerSubscriber(parent, outerValue, outerIndex) {\n    var _this = _super.call(this) || this;\n\n    _this.parent = parent;\n    _this.outerValue = outerValue;\n    _this.outerIndex = outerIndex;\n    _this.index = 0;\n    return _this;\n  }\n\n  InnerSubscriber.prototype._next = function (value) {\n    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n  };\n\n  InnerSubscriber.prototype._error = function (error) {\n    this.parent.notifyError(error, this);\n    this.unsubscribe();\n  };\n\n  InnerSubscriber.prototype._complete = function () {\n    this.parent.notifyComplete(this);\n    this.unsubscribe();\n  };\n\n  return InnerSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */\n\n\nfunction toSubscriber(nextOrObserver, error, complete) {\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber) {\n      return nextOrObserver;\n    }\n\n    if (nextOrObserver[rxSubscriber]) {\n      return nextOrObserver[rxSubscriber]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber(empty);\n  }\n\n  return new Subscriber(nextOrObserver, error, complete);\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar observable = typeof Symbol === 'function' && Symbol.observable || '@@observable';\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\nfunction noop() {}\n/** PURE_IMPORTS_START _noop PURE_IMPORTS_END */\n\n\nfunction pipeFromArray(fns) {\n  if (!fns) {\n    return noop;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input) {\n    return fns.reduce(function (prev, fn) {\n      return fn(prev);\n    }, input);\n  };\n}\n/** PURE_IMPORTS_START _util_toSubscriber,_internal_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */\n\n\nvar Observable =\n/*@__PURE__*/\nfunction () {\n  function Observable(subscribe) {\n    this._isScalar = false;\n\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  Observable.prototype.lift = function (operator) {\n    var observable$$1 = new Observable();\n    observable$$1.source = this;\n    observable$$1.operator = operator;\n    return observable$$1;\n  };\n\n  Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n    var operator = this.operator;\n    var sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      operator.call(sink, this.source);\n    } else {\n      sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));\n    }\n\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      if (sink.syncErrorThrowable) {\n        sink.syncErrorThrowable = false;\n\n        if (sink.syncErrorThrown) {\n          throw sink.syncErrorValue;\n        }\n      }\n    }\n\n    return sink;\n  };\n\n  Observable.prototype._trySubscribe = function (sink) {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        sink.syncErrorThrown = true;\n        sink.syncErrorValue = err;\n      }\n\n      sink.error(err);\n    }\n  };\n\n  Observable.prototype.forEach = function (next, promiseCtor) {\n    var _this = this;\n\n    promiseCtor = getPromiseCtor(promiseCtor);\n    return new promiseCtor(function (resolve, reject) {\n      var subscription;\n      subscription = _this.subscribe(function (value) {\n        try {\n          next(value);\n        } catch (err) {\n          reject(err);\n\n          if (subscription) {\n            subscription.unsubscribe();\n          }\n        }\n      }, reject, resolve);\n    });\n  };\n\n  Observable.prototype._subscribe = function (subscriber) {\n    var source = this.source;\n    return source && source.subscribe(subscriber);\n  };\n\n  Observable.prototype[observable] = function () {\n    return this;\n  };\n\n  Observable.prototype.pipe = function () {\n    var operations = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      operations[_i] = arguments[_i];\n    }\n\n    if (operations.length === 0) {\n      return this;\n    }\n\n    return pipeFromArray(operations)(this);\n  };\n\n  Observable.prototype.toPromise = function (promiseCtor) {\n    var _this = this;\n\n    promiseCtor = getPromiseCtor(promiseCtor);\n    return new promiseCtor(function (resolve, reject) {\n      var value;\n\n      _this.subscribe(function (x) {\n        return value = x;\n      }, function (err) {\n        return reject(err);\n      }, function () {\n        return resolve(value);\n      });\n    });\n  };\n\n  Observable.create = function (subscribe) {\n    return new Observable(subscribe);\n  };\n\n  return Observable;\n}();\n\nfunction getPromiseCtor(promiseCtor) {\n  if (!promiseCtor) {\n    promiseCtor = config.Promise || Promise;\n  }\n\n  if (!promiseCtor) {\n    throw new Error('no Promise impl found');\n  }\n\n  return promiseCtor;\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar subscribeToArray = function subscribeToArray(array) {\n  return function (subscriber) {\n    for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {\n      subscriber.next(array[i]);\n    }\n\n    if (!subscriber.closed) {\n      subscriber.complete();\n    }\n  };\n};\n/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */\n\n\nvar subscribeToPromise = function subscribeToPromise(promise) {\n  return function (subscriber) {\n    promise.then(function (value) {\n      if (!subscriber.closed) {\n        subscriber.next(value);\n        subscriber.complete();\n      }\n    }, function (err) {\n      return subscriber.error(err);\n    }).then(null, hostReportError);\n    return subscriber;\n  };\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction getSymbolIterator() {\n  if (typeof Symbol !== 'function' || !Symbol.iterator) {\n    return '@@iterator';\n  }\n\n  return Symbol.iterator;\n}\n\nvar iterator =\n/*@__PURE__*/\ngetSymbolIterator();\n/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */\n\nvar subscribeToIterable = function subscribeToIterable(iterable) {\n  return function (subscriber) {\n    var iterator$$1 = iterable[iterator]();\n\n    do {\n      var item = iterator$$1.next();\n\n      if (item.done) {\n        subscriber.complete();\n        break;\n      }\n\n      subscriber.next(item.value);\n\n      if (subscriber.closed) {\n        break;\n      }\n    } while (true);\n\n    if (typeof iterator$$1.return === 'function') {\n      subscriber.add(function () {\n        if (iterator$$1.return) {\n          iterator$$1.return();\n        }\n      });\n    }\n\n    return subscriber;\n  };\n};\n/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */\n\n\nvar subscribeToObservable = function subscribeToObservable(obj) {\n  return function (subscriber) {\n    var obs = obj[observable]();\n\n    if (typeof obs.subscribe !== 'function') {\n      throw new TypeError('Provided object does not correctly implement Symbol.observable');\n    } else {\n      return obs.subscribe(subscriber);\n    }\n  };\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar isArrayLike = function isArrayLike(x) {\n  return x && typeof x.length === 'number' && typeof x !== 'function';\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction isPromise(value) {\n  return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n}\n/** PURE_IMPORTS_START _Observable,_subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */\n\n\nvar subscribeTo = function subscribeTo(result) {\n  if (result instanceof Observable) {\n    return function (subscriber) {\n      if (result._isScalar) {\n        subscriber.next(result.value);\n        subscriber.complete();\n        return undefined;\n      } else {\n        return result.subscribe(subscriber);\n      }\n    };\n  } else if (result && typeof result[observable] === 'function') {\n    return subscribeToObservable(result);\n  } else if (isArrayLike(result)) {\n    return subscribeToArray(result);\n  } else if (isPromise(result)) {\n    return subscribeToPromise(result);\n  } else if (result && typeof result[iterator] === 'function') {\n    return subscribeToIterable(result);\n  } else {\n    var value = isObject(result) ? 'an invalid object' : \"'\" + result + \"'\";\n    var msg = \"You provided \" + value + \" where a stream was expected.\" + ' You can provide an Observable, Promise, Array, or Iterable.';\n    throw new TypeError(msg);\n  }\n};\n/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo PURE_IMPORTS_END */\n\n\nfunction subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {\n  var destination = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n  return subscribeTo(result)(destination);\n}\n/** PURE_IMPORTS_START tslib,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\n\n\nvar AuditSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(AuditSubscriber, _super);\n\n  function AuditSubscriber(destination, durationSelector) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.durationSelector = durationSelector;\n    _this.hasValue = false;\n    return _this;\n  }\n\n  AuditSubscriber.prototype._next = function (value) {\n    this.value = value;\n    this.hasValue = true;\n\n    if (!this.throttled) {\n      var duration = tryCatch(this.durationSelector)(value);\n\n      if (duration === errorObject) {\n        this.destination.error(errorObject.e);\n      } else {\n        var innerSubscription = subscribeToResult(this, duration);\n\n        if (!innerSubscription || innerSubscription.closed) {\n          this.clearThrottle();\n        } else {\n          this.add(this.throttled = innerSubscription);\n        }\n      }\n    }\n  };\n\n  AuditSubscriber.prototype.clearThrottle = function () {\n    var _a = this,\n        value = _a.value,\n        hasValue = _a.hasValue,\n        throttled = _a.throttled;\n\n    if (throttled) {\n      this.remove(throttled);\n      this.throttled = null;\n      throttled.unsubscribe();\n    }\n\n    if (hasValue) {\n      this.value = null;\n      this.hasValue = false;\n      this.destination.next(value);\n    }\n  };\n\n  AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n    this.clearThrottle();\n  };\n\n  AuditSubscriber.prototype.notifyComplete = function () {\n    this.clearThrottle();\n  };\n\n  return AuditSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */\n\n\nvar Action =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(Action, _super);\n\n  function Action(scheduler, work) {\n    return _super.call(this) || this;\n  }\n\n  Action.prototype.schedule = function (state, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    return this;\n  };\n\n  return Action;\n}(Subscription);\n/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */\n\n\nvar AsyncAction =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(AsyncAction, _super);\n\n  function AsyncAction(scheduler, work) {\n    var _this = _super.call(this, scheduler, work) || this;\n\n    _this.scheduler = scheduler;\n    _this.work = work;\n    _this.pending = false;\n    return _this;\n  }\n\n  AsyncAction.prototype.schedule = function (state, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (this.closed) {\n      return this;\n    }\n\n    this.state = state;\n    var id = this.id;\n    var scheduler = this.scheduler;\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    this.pending = true;\n    this.delay = delay;\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n    return this;\n  };\n\n  AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    return setInterval(scheduler.flush.bind(scheduler, this), delay);\n  };\n\n  AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n\n    return clearInterval(id) && undefined || undefined;\n  };\n\n  AsyncAction.prototype.execute = function (state, delay) {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n\n    var error = this._execute(state, delay);\n\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  };\n\n  AsyncAction.prototype._execute = function (state, delay) {\n    var errored = false;\n    var errorValue = undefined;\n\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  };\n\n  AsyncAction.prototype._unsubscribe = function () {\n    var id = this.id;\n    var scheduler = this.scheduler;\n    var actions = scheduler.actions;\n    var index = actions.indexOf(this);\n    this.work = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  };\n\n  return AsyncAction;\n}(Action);\n\nvar Scheduler =\n/*@__PURE__*/\nfunction () {\n  function Scheduler(SchedulerAction, now) {\n    if (now === void 0) {\n      now = Scheduler.now;\n    }\n\n    this.SchedulerAction = SchedulerAction;\n    this.now = now;\n  }\n\n  Scheduler.prototype.schedule = function (work, delay, state) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    return new this.SchedulerAction(this, work).schedule(state, delay);\n  };\n\n  Scheduler.now = function () {\n    return Date.now();\n  };\n\n  return Scheduler;\n}();\n/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */\n\n\nvar AsyncScheduler =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(AsyncScheduler, _super);\n\n  function AsyncScheduler(SchedulerAction, now) {\n    if (now === void 0) {\n      now = Scheduler.now;\n    }\n\n    var _this = _super.call(this, SchedulerAction, function () {\n      if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {\n        return AsyncScheduler.delegate.now();\n      } else {\n        return now();\n      }\n    }) || this;\n\n    _this.actions = [];\n    _this.active = false;\n    _this.scheduled = undefined;\n    return _this;\n  }\n\n  AsyncScheduler.prototype.schedule = function (work, delay, state) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n      return AsyncScheduler.delegate.schedule(work, delay, state);\n    } else {\n      return _super.prototype.schedule.call(this, work, delay, state);\n    }\n  };\n\n  AsyncScheduler.prototype.flush = function (action) {\n    var actions = this.actions;\n\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n\n    var error;\n    this.active = true;\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift());\n\n    this.active = false;\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n\n      throw error;\n    }\n  };\n\n  return AsyncScheduler;\n}(Scheduler);\n/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */\n\n\nvar async =\n/*@__PURE__*/\nnew AsyncScheduler(AsyncAction);\n/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */\n\nfunction isNumeric(val) {\n  return !isArray(val) && val - parseFloat(val) + 1 >= 0;\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction isScheduler(value) {\n  return value && typeof value.schedule === 'function';\n}\n/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _scheduler_async,_audit,_observable_timer PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\n\n\nvar BufferSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(BufferSubscriber, _super);\n\n  function BufferSubscriber(destination, closingNotifier) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.buffer = [];\n\n    _this.add(subscribeToResult(_this, closingNotifier));\n\n    return _this;\n  }\n\n  BufferSubscriber.prototype._next = function (value) {\n    this.buffer.push(value);\n  };\n\n  BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    var buffer = this.buffer;\n    this.buffer = [];\n    this.destination.next(buffer);\n  };\n\n  return BufferSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nvar BufferCountSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(BufferCountSubscriber, _super);\n\n  function BufferCountSubscriber(destination, bufferSize) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.bufferSize = bufferSize;\n    _this.buffer = [];\n    return _this;\n  }\n\n  BufferCountSubscriber.prototype._next = function (value) {\n    var buffer = this.buffer;\n    buffer.push(value);\n\n    if (buffer.length == this.bufferSize) {\n      this.destination.next(buffer);\n      this.buffer = [];\n    }\n  };\n\n  BufferCountSubscriber.prototype._complete = function () {\n    var buffer = this.buffer;\n\n    if (buffer.length > 0) {\n      this.destination.next(buffer);\n    }\n\n    _super.prototype._complete.call(this);\n  };\n\n  return BufferCountSubscriber;\n}(Subscriber);\n\nvar BufferSkipCountSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(BufferSkipCountSubscriber, _super);\n\n  function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.bufferSize = bufferSize;\n    _this.startBufferEvery = startBufferEvery;\n    _this.buffers = [];\n    _this.count = 0;\n    return _this;\n  }\n\n  BufferSkipCountSubscriber.prototype._next = function (value) {\n    var _a = this,\n        bufferSize = _a.bufferSize,\n        startBufferEvery = _a.startBufferEvery,\n        buffers = _a.buffers,\n        count = _a.count;\n\n    this.count++;\n\n    if (count % startBufferEvery === 0) {\n      buffers.push([]);\n    }\n\n    for (var i = buffers.length; i--;) {\n      var buffer = buffers[i];\n      buffer.push(value);\n\n      if (buffer.length === bufferSize) {\n        buffers.splice(i, 1);\n        this.destination.next(buffer);\n      }\n    }\n  };\n\n  BufferSkipCountSubscriber.prototype._complete = function () {\n    var _a = this,\n        buffers = _a.buffers,\n        destination = _a.destination;\n\n    while (buffers.length > 0) {\n      var buffer = buffers.shift();\n\n      if (buffer.length > 0) {\n        destination.next(buffer);\n      }\n    }\n\n    _super.prototype._complete.call(this);\n  };\n\n  return BufferSkipCountSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */\n\n\nvar Context =\n/*@__PURE__*/\nfunction () {\n  function Context() {\n    this.buffer = [];\n  }\n\n  return Context;\n}();\n\nvar BufferTimeSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(BufferTimeSubscriber, _super);\n\n  function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.bufferTimeSpan = bufferTimeSpan;\n    _this.bufferCreationInterval = bufferCreationInterval;\n    _this.maxBufferSize = maxBufferSize;\n    _this.scheduler = scheduler;\n    _this.contexts = [];\n\n    var context = _this.openContext();\n\n    _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n\n    if (_this.timespanOnly) {\n      var timeSpanOnlyState = {\n        subscriber: _this,\n        context: context,\n        bufferTimeSpan: bufferTimeSpan\n      };\n\n      _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    } else {\n      var closeState = {\n        subscriber: _this,\n        context: context\n      };\n      var creationState = {\n        bufferTimeSpan: bufferTimeSpan,\n        bufferCreationInterval: bufferCreationInterval,\n        subscriber: _this,\n        scheduler: scheduler\n      };\n\n      _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n\n      _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n    }\n\n    return _this;\n  }\n\n  BufferTimeSubscriber.prototype._next = function (value) {\n    var contexts = this.contexts;\n    var len = contexts.length;\n    var filledBufferContext;\n\n    for (var i = 0; i < len; i++) {\n      var context_1 = contexts[i];\n      var buffer = context_1.buffer;\n      buffer.push(value);\n\n      if (buffer.length == this.maxBufferSize) {\n        filledBufferContext = context_1;\n      }\n    }\n\n    if (filledBufferContext) {\n      this.onBufferFull(filledBufferContext);\n    }\n  };\n\n  BufferTimeSubscriber.prototype._error = function (err) {\n    this.contexts.length = 0;\n\n    _super.prototype._error.call(this, err);\n  };\n\n  BufferTimeSubscriber.prototype._complete = function () {\n    var _a = this,\n        contexts = _a.contexts,\n        destination = _a.destination;\n\n    while (contexts.length > 0) {\n      var context_2 = contexts.shift();\n      destination.next(context_2.buffer);\n    }\n\n    _super.prototype._complete.call(this);\n  };\n\n  BufferTimeSubscriber.prototype._unsubscribe = function () {\n    this.contexts = null;\n  };\n\n  BufferTimeSubscriber.prototype.onBufferFull = function (context) {\n    this.closeContext(context);\n    var closeAction = context.closeAction;\n    closeAction.unsubscribe();\n    this.remove(closeAction);\n\n    if (!this.closed && this.timespanOnly) {\n      context = this.openContext();\n      var bufferTimeSpan = this.bufferTimeSpan;\n      var timeSpanOnlyState = {\n        subscriber: this,\n        context: context,\n        bufferTimeSpan: bufferTimeSpan\n      };\n      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    }\n  };\n\n  BufferTimeSubscriber.prototype.openContext = function () {\n    var context = new Context();\n    this.contexts.push(context);\n    return context;\n  };\n\n  BufferTimeSubscriber.prototype.closeContext = function (context) {\n    this.destination.next(context.buffer);\n    var contexts = this.contexts;\n    var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n\n    if (spliceIndex >= 0) {\n      contexts.splice(contexts.indexOf(context), 1);\n    }\n  };\n\n  return BufferTimeSubscriber;\n}(Subscriber);\n\nfunction dispatchBufferTimeSpanOnly(state) {\n  var subscriber = state.subscriber;\n  var prevContext = state.context;\n\n  if (prevContext) {\n    subscriber.closeContext(prevContext);\n  }\n\n  if (!subscriber.closed) {\n    state.context = subscriber.openContext();\n    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n  }\n}\n\nfunction dispatchBufferCreation(state) {\n  var bufferCreationInterval = state.bufferCreationInterval,\n      bufferTimeSpan = state.bufferTimeSpan,\n      subscriber = state.subscriber,\n      scheduler = state.scheduler;\n  var context = subscriber.openContext();\n  var action = this;\n\n  if (!subscriber.closed) {\n    subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, {\n      subscriber: subscriber,\n      context: context\n    }));\n    action.schedule(state, bufferCreationInterval);\n  }\n}\n\nfunction dispatchBufferClose(arg) {\n  var subscriber = arg.subscriber,\n      context = arg.context;\n  subscriber.closeContext(context);\n}\n/** PURE_IMPORTS_START tslib,_Subscription,_util_subscribeToResult,_OuterSubscriber PURE_IMPORTS_END */\n\n\nvar BufferToggleSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(BufferToggleSubscriber, _super);\n\n  function BufferToggleSubscriber(destination, openings, closingSelector) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.openings = openings;\n    _this.closingSelector = closingSelector;\n    _this.contexts = [];\n\n    _this.add(subscribeToResult(_this, openings));\n\n    return _this;\n  }\n\n  BufferToggleSubscriber.prototype._next = function (value) {\n    var contexts = this.contexts;\n    var len = contexts.length;\n\n    for (var i = 0; i < len; i++) {\n      contexts[i].buffer.push(value);\n    }\n  };\n\n  BufferToggleSubscriber.prototype._error = function (err) {\n    var contexts = this.contexts;\n\n    while (contexts.length > 0) {\n      var context_1 = contexts.shift();\n      context_1.subscription.unsubscribe();\n      context_1.buffer = null;\n      context_1.subscription = null;\n    }\n\n    this.contexts = null;\n\n    _super.prototype._error.call(this, err);\n  };\n\n  BufferToggleSubscriber.prototype._complete = function () {\n    var contexts = this.contexts;\n\n    while (contexts.length > 0) {\n      var context_2 = contexts.shift();\n      this.destination.next(context_2.buffer);\n      context_2.subscription.unsubscribe();\n      context_2.buffer = null;\n      context_2.subscription = null;\n    }\n\n    this.contexts = null;\n\n    _super.prototype._complete.call(this);\n  };\n\n  BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);\n  };\n\n  BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {\n    this.closeBuffer(innerSub.context);\n  };\n\n  BufferToggleSubscriber.prototype.openBuffer = function (value) {\n    try {\n      var closingSelector = this.closingSelector;\n      var closingNotifier = closingSelector.call(this, value);\n\n      if (closingNotifier) {\n        this.trySubscribe(closingNotifier);\n      }\n    } catch (err) {\n      this._error(err);\n    }\n  };\n\n  BufferToggleSubscriber.prototype.closeBuffer = function (context) {\n    var contexts = this.contexts;\n\n    if (contexts && context) {\n      var buffer = context.buffer,\n          subscription = context.subscription;\n      this.destination.next(buffer);\n      contexts.splice(contexts.indexOf(context), 1);\n      this.remove(subscription);\n      subscription.unsubscribe();\n    }\n  };\n\n  BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {\n    var contexts = this.contexts;\n    var buffer = [];\n    var subscription = new Subscription();\n    var context = {\n      buffer: buffer,\n      subscription: subscription\n    };\n    contexts.push(context);\n    var innerSubscription = subscribeToResult(this, closingNotifier, context);\n\n    if (!innerSubscription || innerSubscription.closed) {\n      this.closeBuffer(context);\n    } else {\n      innerSubscription.context = context;\n      this.add(innerSubscription);\n      subscription.add(innerSubscription);\n    }\n  };\n\n  return BufferToggleSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START tslib,_Subscription,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\n\n\nvar BufferWhenSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(BufferWhenSubscriber, _super);\n\n  function BufferWhenSubscriber(destination, closingSelector) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.closingSelector = closingSelector;\n    _this.subscribing = false;\n\n    _this.openBuffer();\n\n    return _this;\n  }\n\n  BufferWhenSubscriber.prototype._next = function (value) {\n    this.buffer.push(value);\n  };\n\n  BufferWhenSubscriber.prototype._complete = function () {\n    var buffer = this.buffer;\n\n    if (buffer) {\n      this.destination.next(buffer);\n    }\n\n    _super.prototype._complete.call(this);\n  };\n\n  BufferWhenSubscriber.prototype._unsubscribe = function () {\n    this.buffer = null;\n    this.subscribing = false;\n  };\n\n  BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.openBuffer();\n  };\n\n  BufferWhenSubscriber.prototype.notifyComplete = function () {\n    if (this.subscribing) {\n      this.complete();\n    } else {\n      this.openBuffer();\n    }\n  };\n\n  BufferWhenSubscriber.prototype.openBuffer = function () {\n    var closingSubscription = this.closingSubscription;\n\n    if (closingSubscription) {\n      this.remove(closingSubscription);\n      closingSubscription.unsubscribe();\n    }\n\n    var buffer = this.buffer;\n\n    if (this.buffer) {\n      this.destination.next(buffer);\n    }\n\n    this.buffer = [];\n    var closingNotifier = tryCatch(this.closingSelector)();\n\n    if (closingNotifier === errorObject) {\n      this.error(errorObject.e);\n    } else {\n      closingSubscription = new Subscription();\n      this.closingSubscription = closingSubscription;\n      this.add(closingSubscription);\n      this.subscribing = true;\n      closingSubscription.add(subscribeToResult(this, closingNotifier));\n      this.subscribing = false;\n    }\n  };\n\n  return BufferWhenSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\n\n\nvar CatchSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(CatchSubscriber, _super);\n\n  function CatchSubscriber(destination, selector, caught) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.selector = selector;\n    _this.caught = caught;\n    return _this;\n  }\n\n  CatchSubscriber.prototype.error = function (err) {\n    if (!this.isStopped) {\n      var result = void 0;\n\n      try {\n        result = this.selector(err, this.caught);\n      } catch (err2) {\n        _super.prototype.error.call(this, err2);\n\n        return;\n      }\n\n      this._unsubscribeAndRecycle();\n\n      this.add(subscribeToResult(this, result));\n    }\n  };\n\n  return CatchSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToArray PURE_IMPORTS_END */\n\n\nfunction fromArray(input, scheduler) {\n  if (!scheduler) {\n    return new Observable(subscribeToArray(input));\n  } else {\n    return new Observable(function (subscriber) {\n      var sub = new Subscription();\n      var i = 0;\n      sub.add(scheduler.schedule(function () {\n        if (i === input.length) {\n          subscriber.complete();\n          return;\n        }\n\n        subscriber.next(input[i++]);\n\n        if (!subscriber.closed) {\n          sub.add(this.schedule());\n        }\n      }));\n      return sub;\n    });\n  }\n}\n/** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */\n\n\nvar NONE = {};\n\nvar CombineLatestSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(CombineLatestSubscriber, _super);\n\n  function CombineLatestSubscriber(destination, resultSelector) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.resultSelector = resultSelector;\n    _this.active = 0;\n    _this.values = [];\n    _this.observables = [];\n    return _this;\n  }\n\n  CombineLatestSubscriber.prototype._next = function (observable) {\n    this.values.push(NONE);\n    this.observables.push(observable);\n  };\n\n  CombineLatestSubscriber.prototype._complete = function () {\n    var observables = this.observables;\n    var len = observables.length;\n\n    if (len === 0) {\n      this.destination.complete();\n    } else {\n      this.active = len;\n      this.toRespond = len;\n\n      for (var i = 0; i < len; i++) {\n        var observable = observables[i];\n        this.add(subscribeToResult(this, observable, observable, i));\n      }\n    }\n  };\n\n  CombineLatestSubscriber.prototype.notifyComplete = function (unused) {\n    if ((this.active -= 1) === 0) {\n      this.destination.complete();\n    }\n  };\n\n  CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    var values = this.values;\n    var oldVal = values[outerIndex];\n    var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;\n    values[outerIndex] = innerValue;\n\n    if (toRespond === 0) {\n      if (this.resultSelector) {\n        this._tryResultSelector(values);\n      } else {\n        this.destination.next(values.slice());\n      }\n    }\n  };\n\n  CombineLatestSubscriber.prototype._tryResultSelector = function (values) {\n    var result;\n\n    try {\n      result = this.resultSelector.apply(this, values);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this.destination.next(result);\n  };\n\n  return CombineLatestSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START _observable_combineLatest PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToPromise PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator,_util_subscribeToIterable PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable,_util_subscribeToObservable PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _Observable,_util_isPromise,_util_isArrayLike,_util_isInteropObservable,_util_isIterable,_fromArray,_fromPromise,_fromIterable,_fromObservable,_util_subscribeTo PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _util_isArray,_observable_combineLatest,_observable_from PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\n\n\nvar EMPTY =\n/*@__PURE__*/\nnew Observable(function (subscriber) {\n  return subscriber.complete();\n});\n\nfunction empty$1(scheduler) {\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\n\nfunction emptyScheduled(scheduler) {\n  return new Observable(function (subscriber) {\n    return scheduler.schedule(function () {\n      return subscriber.complete();\n    });\n  });\n}\n/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\n\n\nfunction scalar(value) {\n  var result = new Observable(function (subscriber) {\n    subscriber.next(value);\n    subscriber.complete();\n  });\n  result._isScalar = true;\n  result.value = value;\n  return result;\n}\n/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_empty,_scalar PURE_IMPORTS_END */\n\n\nfunction of() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  var scheduler = args[args.length - 1];\n\n  if (isScheduler(scheduler)) {\n    args.pop();\n  } else {\n    scheduler = undefined;\n  }\n\n  switch (args.length) {\n    case 0:\n      return empty$1(scheduler);\n\n    case 1:\n      return scheduler ? fromArray(args, scheduler) : scalar(args[0]);\n\n    default:\n      return fromArray(args, scheduler);\n  }\n}\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nvar MapSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(MapSubscriber, _super);\n\n  function MapSubscriber(destination, project, thisArg) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.project = project;\n    _this.count = 0;\n    _this.thisArg = thisArg || _this;\n    return _this;\n  }\n\n  MapSubscriber.prototype._next = function (value) {\n    var result;\n\n    try {\n      result = this.project.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this.destination.next(result);\n  };\n\n  return MapSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_map,_observable_from PURE_IMPORTS_END */\n\n\nvar MergeMapSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(MergeMapSubscriber, _super);\n\n  function MergeMapSubscriber(destination, project, concurrent) {\n    if (concurrent === void 0) {\n      concurrent = Number.POSITIVE_INFINITY;\n    }\n\n    var _this = _super.call(this, destination) || this;\n\n    _this.project = project;\n    _this.concurrent = concurrent;\n    _this.hasCompleted = false;\n    _this.buffer = [];\n    _this.active = 0;\n    _this.index = 0;\n    return _this;\n  }\n\n  MergeMapSubscriber.prototype._next = function (value) {\n    if (this.active < this.concurrent) {\n      this._tryNext(value);\n    } else {\n      this.buffer.push(value);\n    }\n  };\n\n  MergeMapSubscriber.prototype._tryNext = function (value) {\n    var result;\n    var index = this.index++;\n\n    try {\n      result = this.project(value, index);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this.active++;\n\n    this._innerSub(result, value, index);\n  };\n\n  MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {\n    this.add(subscribeToResult(this, ish, value, index));\n  };\n\n  MergeMapSubscriber.prototype._complete = function () {\n    this.hasCompleted = true;\n\n    if (this.active === 0 && this.buffer.length === 0) {\n      this.destination.complete();\n    }\n  };\n\n  MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.destination.next(innerValue);\n  };\n\n  MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {\n    var buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      this.destination.complete();\n    }\n  };\n\n  return MergeMapSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _util_isScheduler,_of,_from,_operators_concatAll PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _observable_concat PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _concatMap PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nvar CountSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(CountSubscriber, _super);\n\n  function CountSubscriber(destination, predicate, source) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.predicate = predicate;\n    _this.source = source;\n    _this.count = 0;\n    _this.index = 0;\n    return _this;\n  }\n\n  CountSubscriber.prototype._next = function (value) {\n    if (this.predicate) {\n      this._tryPredicate(value);\n    } else {\n      this.count++;\n    }\n  };\n\n  CountSubscriber.prototype._tryPredicate = function (value) {\n    var result;\n\n    try {\n      result = this.predicate(value, this.index++, this.source);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    if (result) {\n      this.count++;\n    }\n  };\n\n  CountSubscriber.prototype._complete = function () {\n    this.destination.next(this.count);\n    this.destination.complete();\n  };\n\n  return CountSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\n\n\nvar DebounceSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(DebounceSubscriber, _super);\n\n  function DebounceSubscriber(destination, durationSelector) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.durationSelector = durationSelector;\n    _this.hasValue = false;\n    _this.durationSubscription = null;\n    return _this;\n  }\n\n  DebounceSubscriber.prototype._next = function (value) {\n    try {\n      var result = this.durationSelector.call(this, value);\n\n      if (result) {\n        this._tryNext(value, result);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  };\n\n  DebounceSubscriber.prototype._complete = function () {\n    this.emitValue();\n    this.destination.complete();\n  };\n\n  DebounceSubscriber.prototype._tryNext = function (value, duration) {\n    var subscription = this.durationSubscription;\n    this.value = value;\n    this.hasValue = true;\n\n    if (subscription) {\n      subscription.unsubscribe();\n      this.remove(subscription);\n    }\n\n    subscription = subscribeToResult(this, duration);\n\n    if (subscription && !subscription.closed) {\n      this.add(this.durationSubscription = subscription);\n    }\n  };\n\n  DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.emitValue();\n  };\n\n  DebounceSubscriber.prototype.notifyComplete = function () {\n    this.emitValue();\n  };\n\n  DebounceSubscriber.prototype.emitValue = function () {\n    if (this.hasValue) {\n      var value = this.value;\n      var subscription = this.durationSubscription;\n\n      if (subscription) {\n        this.durationSubscription = null;\n        subscription.unsubscribe();\n        this.remove(subscription);\n      }\n\n      this.value = null;\n      this.hasValue = false;\n\n      _super.prototype._next.call(this, value);\n    }\n  };\n\n  return DebounceSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */\n\n\nvar DebounceTimeSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(DebounceTimeSubscriber, _super);\n\n  function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.dueTime = dueTime;\n    _this.scheduler = scheduler;\n    _this.debouncedSubscription = null;\n    _this.lastValue = null;\n    _this.hasValue = false;\n    return _this;\n  }\n\n  DebounceTimeSubscriber.prototype._next = function (value) {\n    this.clearDebounce();\n    this.lastValue = value;\n    this.hasValue = true;\n    this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n  };\n\n  DebounceTimeSubscriber.prototype._complete = function () {\n    this.debouncedNext();\n    this.destination.complete();\n  };\n\n  DebounceTimeSubscriber.prototype.debouncedNext = function () {\n    this.clearDebounce();\n\n    if (this.hasValue) {\n      var lastValue = this.lastValue;\n      this.lastValue = null;\n      this.hasValue = false;\n      this.destination.next(lastValue);\n    }\n  };\n\n  DebounceTimeSubscriber.prototype.clearDebounce = function () {\n    var debouncedSubscription = this.debouncedSubscription;\n\n    if (debouncedSubscription !== null) {\n      this.remove(debouncedSubscription);\n      debouncedSubscription.unsubscribe();\n      this.debouncedSubscription = null;\n    }\n  };\n\n  return DebounceTimeSubscriber;\n}(Subscriber);\n\nfunction dispatchNext(subscriber) {\n  subscriber.debouncedNext();\n}\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nvar DefaultIfEmptySubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(DefaultIfEmptySubscriber, _super);\n\n  function DefaultIfEmptySubscriber(destination, defaultValue) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.defaultValue = defaultValue;\n    _this.isEmpty = true;\n    return _this;\n  }\n\n  DefaultIfEmptySubscriber.prototype._next = function (value) {\n    this.isEmpty = false;\n    this.destination.next(value);\n  };\n\n  DefaultIfEmptySubscriber.prototype._complete = function () {\n    if (this.isEmpty) {\n      this.destination.next(this.defaultValue);\n    }\n\n    this.destination.complete();\n  };\n\n  return DefaultIfEmptySubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\n\n\nfunction throwError(error, scheduler) {\n  if (!scheduler) {\n    return new Observable(function (subscriber) {\n      return subscriber.error(error);\n    });\n  } else {\n    return new Observable(function (subscriber) {\n      return scheduler.schedule(dispatch$1, 0, {\n        error: error,\n        subscriber: subscriber\n      });\n    });\n  }\n}\n\nfunction dispatch$1(_a) {\n  var error = _a.error,\n      subscriber = _a.subscriber;\n  subscriber.error(error);\n}\n/** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */\n\n\nvar Notification =\n/*@__PURE__*/\nfunction () {\n  function Notification(kind, value, error) {\n    this.kind = kind;\n    this.value = value;\n    this.error = error;\n    this.hasValue = kind === 'N';\n  }\n\n  Notification.prototype.observe = function (observer) {\n    switch (this.kind) {\n      case 'N':\n        return observer.next && observer.next(this.value);\n\n      case 'E':\n        return observer.error && observer.error(this.error);\n\n      case 'C':\n        return observer.complete && observer.complete();\n    }\n  };\n\n  Notification.prototype.do = function (next, error, complete) {\n    var kind = this.kind;\n\n    switch (kind) {\n      case 'N':\n        return next && next(this.value);\n\n      case 'E':\n        return error && error(this.error);\n\n      case 'C':\n        return complete && complete();\n    }\n  };\n\n  Notification.prototype.accept = function (nextOrObserver, error, complete) {\n    if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n      return this.observe(nextOrObserver);\n    } else {\n      return this.do(nextOrObserver, error, complete);\n    }\n  };\n\n  Notification.prototype.toObservable = function () {\n    var kind = this.kind;\n\n    switch (kind) {\n      case 'N':\n        return of(this.value);\n\n      case 'E':\n        return throwError(this.error);\n\n      case 'C':\n        return empty$1();\n    }\n\n    throw new Error('unexpected notification kind value');\n  };\n\n  Notification.createNext = function (value) {\n    if (typeof value !== 'undefined') {\n      return new Notification('N', value);\n    }\n\n    return Notification.undefinedValueNotification;\n  };\n\n  Notification.createError = function (err) {\n    return new Notification('E', undefined, err);\n  };\n\n  Notification.createComplete = function () {\n    return Notification.completeNotification;\n  };\n\n  Notification.completeNotification = new Notification('C');\n  Notification.undefinedValueNotification = new Notification('N', undefined);\n  return Notification;\n}();\n/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */\n\n\nvar DelaySubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(DelaySubscriber, _super);\n\n  function DelaySubscriber(destination, delay, scheduler) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.delay = delay;\n    _this.scheduler = scheduler;\n    _this.queue = [];\n    _this.active = false;\n    _this.errored = false;\n    return _this;\n  }\n\n  DelaySubscriber.dispatch = function (state) {\n    var source = state.source;\n    var queue = source.queue;\n    var scheduler = state.scheduler;\n    var destination = state.destination;\n\n    while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {\n      queue.shift().notification.observe(destination);\n    }\n\n    if (queue.length > 0) {\n      var delay_1 = Math.max(0, queue[0].time - scheduler.now());\n      this.schedule(state, delay_1);\n    } else {\n      this.unsubscribe();\n      source.active = false;\n    }\n  };\n\n  DelaySubscriber.prototype._schedule = function (scheduler) {\n    this.active = true;\n    this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {\n      source: this,\n      destination: this.destination,\n      scheduler: scheduler\n    }));\n  };\n\n  DelaySubscriber.prototype.scheduleNotification = function (notification) {\n    if (this.errored === true) {\n      return;\n    }\n\n    var scheduler = this.scheduler;\n    var message = new DelayMessage(scheduler.now() + this.delay, notification);\n    this.queue.push(message);\n\n    if (this.active === false) {\n      this._schedule(scheduler);\n    }\n  };\n\n  DelaySubscriber.prototype._next = function (value) {\n    this.scheduleNotification(Notification.createNext(value));\n  };\n\n  DelaySubscriber.prototype._error = function (err) {\n    this.errored = true;\n    this.queue = [];\n    this.destination.error(err);\n  };\n\n  DelaySubscriber.prototype._complete = function () {\n    this.scheduleNotification(Notification.createComplete());\n  };\n\n  return DelaySubscriber;\n}(Subscriber);\n\nvar DelayMessage =\n/*@__PURE__*/\nfunction () {\n  function DelayMessage(time, notification) {\n    this.time = time;\n    this.notification = notification;\n  }\n\n  return DelayMessage;\n}();\n/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\n\n\nvar DelayWhenSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(DelayWhenSubscriber, _super);\n\n  function DelayWhenSubscriber(destination, delayDurationSelector) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.delayDurationSelector = delayDurationSelector;\n    _this.completed = false;\n    _this.delayNotifierSubscriptions = [];\n    return _this;\n  }\n\n  DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.destination.next(outerValue);\n    this.removeSubscription(innerSub);\n    this.tryComplete();\n  };\n\n  DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {\n    this._error(error);\n  };\n\n  DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {\n    var value = this.removeSubscription(innerSub);\n\n    if (value) {\n      this.destination.next(value);\n    }\n\n    this.tryComplete();\n  };\n\n  DelayWhenSubscriber.prototype._next = function (value) {\n    try {\n      var delayNotifier = this.delayDurationSelector(value);\n\n      if (delayNotifier) {\n        this.tryDelay(delayNotifier, value);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  };\n\n  DelayWhenSubscriber.prototype._complete = function () {\n    this.completed = true;\n    this.tryComplete();\n  };\n\n  DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {\n    subscription.unsubscribe();\n    var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);\n\n    if (subscriptionIdx !== -1) {\n      this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);\n    }\n\n    return subscription.outerValue;\n  };\n\n  DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {\n    var notifierSubscription = subscribeToResult(this, delayNotifier, value);\n\n    if (notifierSubscription && !notifierSubscription.closed) {\n      this.add(notifierSubscription);\n      this.delayNotifierSubscriptions.push(notifierSubscription);\n    }\n  };\n\n  DelayWhenSubscriber.prototype.tryComplete = function () {\n    if (this.completed && this.delayNotifierSubscriptions.length === 0) {\n      this.destination.complete();\n    }\n  };\n\n  return DelayWhenSubscriber;\n}(OuterSubscriber);\n\nvar SubscriptionDelayObservable =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(SubscriptionDelayObservable, _super);\n\n  function SubscriptionDelayObservable(source, subscriptionDelay) {\n    var _this = _super.call(this) || this;\n\n    _this.source = source;\n    _this.subscriptionDelay = subscriptionDelay;\n    return _this;\n  }\n\n  SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {\n    this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));\n  };\n\n  return SubscriptionDelayObservable;\n}(Observable);\n\nvar SubscriptionDelaySubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(SubscriptionDelaySubscriber, _super);\n\n  function SubscriptionDelaySubscriber(parent, source) {\n    var _this = _super.call(this) || this;\n\n    _this.parent = parent;\n    _this.source = source;\n    _this.sourceSubscribed = false;\n    return _this;\n  }\n\n  SubscriptionDelaySubscriber.prototype._next = function (unused) {\n    this.subscribeToSource();\n  };\n\n  SubscriptionDelaySubscriber.prototype._error = function (err) {\n    this.unsubscribe();\n    this.parent.error(err);\n  };\n\n  SubscriptionDelaySubscriber.prototype._complete = function () {\n    this.subscribeToSource();\n  };\n\n  SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {\n    if (!this.sourceSubscribed) {\n      this.sourceSubscribed = true;\n      this.unsubscribe();\n      this.source.subscribe(this.parent);\n    }\n  };\n\n  return SubscriptionDelaySubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nvar DeMaterializeSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(DeMaterializeSubscriber, _super);\n\n  function DeMaterializeSubscriber(destination) {\n    return _super.call(this, destination) || this;\n  }\n\n  DeMaterializeSubscriber.prototype._next = function (value) {\n    value.observe(this.destination);\n  };\n\n  return DeMaterializeSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\n\n\nvar DistinctSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(DistinctSubscriber, _super);\n\n  function DistinctSubscriber(destination, keySelector, flushes) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.keySelector = keySelector;\n    _this.values = new Set();\n\n    if (flushes) {\n      _this.add(subscribeToResult(_this, flushes));\n    }\n\n    return _this;\n  }\n\n  DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.values.clear();\n  };\n\n  DistinctSubscriber.prototype.notifyError = function (error, innerSub) {\n    this._error(error);\n  };\n\n  DistinctSubscriber.prototype._next = function (value) {\n    if (this.keySelector) {\n      this._useKeySelector(value);\n    } else {\n      this._finalizeNext(value, value);\n    }\n  };\n\n  DistinctSubscriber.prototype._useKeySelector = function (value) {\n    var key;\n    var destination = this.destination;\n\n    try {\n      key = this.keySelector(value);\n    } catch (err) {\n      destination.error(err);\n      return;\n    }\n\n    this._finalizeNext(key, value);\n  };\n\n  DistinctSubscriber.prototype._finalizeNext = function (key, value) {\n    var values = this.values;\n\n    if (!values.has(key)) {\n      values.add(key);\n      this.destination.next(value);\n    }\n  };\n\n  return DistinctSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber,_util_tryCatch,_util_errorObject PURE_IMPORTS_END */\n\n\nvar DistinctUntilChangedSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(DistinctUntilChangedSubscriber, _super);\n\n  function DistinctUntilChangedSubscriber(destination, compare, keySelector) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.keySelector = keySelector;\n    _this.hasKey = false;\n\n    if (typeof compare === 'function') {\n      _this.compare = compare;\n    }\n\n    return _this;\n  }\n\n  DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {\n    return x === y;\n  };\n\n  DistinctUntilChangedSubscriber.prototype._next = function (value) {\n    var keySelector = this.keySelector;\n    var key = value;\n\n    if (keySelector) {\n      key = tryCatch(this.keySelector)(value);\n\n      if (key === errorObject) {\n        return this.destination.error(errorObject.e);\n      }\n    }\n\n    var result = false;\n\n    if (this.hasKey) {\n      result = tryCatch(this.compare)(this.key, key);\n\n      if (result === errorObject) {\n        return this.destination.error(errorObject.e);\n      }\n    } else {\n      this.hasKey = true;\n    }\n\n    if (Boolean(result) === false) {\n      this.key = key;\n      this.destination.next(value);\n    }\n  };\n\n  return DistinctUntilChangedSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START _distinctUntilChanged PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START tslib PURE_IMPORTS_END */\n\n\nvar ArgumentOutOfRangeError =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(ArgumentOutOfRangeError, _super);\n\n  function ArgumentOutOfRangeError() {\n    var _this = _super.call(this, 'argument out of range') || this;\n\n    _this.name = 'ArgumentOutOfRangeError';\n    Object.setPrototypeOf(_this, ArgumentOutOfRangeError.prototype);\n    return _this;\n  }\n\n  return ArgumentOutOfRangeError;\n}(Error);\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nfunction filter(predicate, thisArg) {\n  return function filterOperatorFunction(source) {\n    return source.lift(new FilterOperator(predicate, thisArg));\n  };\n}\n\nvar FilterOperator =\n/*@__PURE__*/\nfunction () {\n  function FilterOperator(predicate, thisArg) {\n    this.predicate = predicate;\n    this.thisArg = thisArg;\n  }\n\n  FilterOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n  };\n\n  return FilterOperator;\n}();\n\nvar FilterSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(FilterSubscriber, _super);\n\n  function FilterSubscriber(destination, predicate, thisArg) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.predicate = predicate;\n    _this.thisArg = thisArg;\n    _this.count = 0;\n    return _this;\n  }\n\n  FilterSubscriber.prototype._next = function (value) {\n    var result;\n\n    try {\n      result = this.predicate.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    if (result) {\n      this.destination.next(value);\n    }\n  };\n\n  return FilterSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */\n\n\nvar TapSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(TapSubscriber, _super);\n\n  function TapSubscriber(destination, observerOrNext, error, complete) {\n    var _this = _super.call(this, destination) || this;\n\n    _this._tapNext = noop;\n    _this._tapError = noop;\n    _this._tapComplete = noop;\n    _this._tapError = error || noop;\n    _this._tapComplete = complete || noop;\n\n    if (isFunction(observerOrNext)) {\n      _this._context = _this;\n      _this._tapNext = observerOrNext;\n    } else if (observerOrNext) {\n      _this._context = observerOrNext;\n      _this._tapNext = observerOrNext.next || noop;\n      _this._tapError = observerOrNext.error || noop;\n      _this._tapComplete = observerOrNext.complete || noop;\n    }\n\n    return _this;\n  }\n\n  TapSubscriber.prototype._next = function (value) {\n    try {\n      this._tapNext.call(this._context, value);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this.destination.next(value);\n  };\n\n  TapSubscriber.prototype._error = function (err) {\n    try {\n      this._tapError.call(this._context, err);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this.destination.error(err);\n  };\n\n  TapSubscriber.prototype._complete = function () {\n    try {\n      this._tapComplete.call(this._context);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    return this.destination.complete();\n  };\n\n  return TapSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib PURE_IMPORTS_END */\n\n\nvar EmptyError =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(EmptyError, _super);\n\n  function EmptyError() {\n    var _this = _super.call(this, 'no elements in sequence') || this;\n\n    _this.name = 'EmptyError';\n    Object.setPrototypeOf(_this, EmptyError.prototype);\n    return _this;\n  }\n\n  return EmptyError;\n}(Error);\n/** PURE_IMPORTS_START _tap,_util_EmptyError PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */\n\n\nvar TakeSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(TakeSubscriber, _super);\n\n  function TakeSubscriber(destination, total) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.total = total;\n    _this.count = 0;\n    return _this;\n  }\n\n  TakeSubscriber.prototype._next = function (value) {\n    var total = this.total;\n    var count = ++this.count;\n\n    if (count <= total) {\n      this.destination.next(value);\n\n      if (count === total) {\n        this.destination.complete();\n        this.unsubscribe();\n      }\n    }\n  };\n\n  return TakeSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START _util_ArgumentOutOfRangeError,_filter,_throwIfEmpty,_defaultIfEmpty,_take PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _observable_fromArray,_observable_scalar,_observable_empty,_observable_concat,_util_isScheduler PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nvar EverySubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(EverySubscriber, _super);\n\n  function EverySubscriber(destination, predicate, thisArg, source) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.predicate = predicate;\n    _this.thisArg = thisArg;\n    _this.source = source;\n    _this.index = 0;\n    _this.thisArg = thisArg || _this;\n    return _this;\n  }\n\n  EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {\n    this.destination.next(everyValueMatch);\n    this.destination.complete();\n  };\n\n  EverySubscriber.prototype._next = function (value) {\n    var result = false;\n\n    try {\n      result = this.predicate.call(this.thisArg, value, this.index++, this.source);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    if (!result) {\n      this.notifyComplete(false);\n    }\n  };\n\n  EverySubscriber.prototype._complete = function () {\n    this.notifyComplete(true);\n  };\n\n  return EverySubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\n\n\nvar SwitchFirstSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(SwitchFirstSubscriber, _super);\n\n  function SwitchFirstSubscriber(destination) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.hasCompleted = false;\n    _this.hasSubscription = false;\n    return _this;\n  }\n\n  SwitchFirstSubscriber.prototype._next = function (value) {\n    if (!this.hasSubscription) {\n      this.hasSubscription = true;\n      this.add(subscribeToResult(this, value));\n    }\n  };\n\n  SwitchFirstSubscriber.prototype._complete = function () {\n    this.hasCompleted = true;\n\n    if (!this.hasSubscription) {\n      this.destination.complete();\n    }\n  };\n\n  SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {\n    this.remove(innerSub);\n    this.hasSubscription = false;\n\n    if (this.hasCompleted) {\n      this.destination.complete();\n    }\n  };\n\n  return SwitchFirstSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */\n\n\nvar ExhaustMapSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(ExhaustMapSubscriber, _super);\n\n  function ExhaustMapSubscriber(destination, project) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.project = project;\n    _this.hasSubscription = false;\n    _this.hasCompleted = false;\n    _this.index = 0;\n    return _this;\n  }\n\n  ExhaustMapSubscriber.prototype._next = function (value) {\n    if (!this.hasSubscription) {\n      this.tryNext(value);\n    }\n  };\n\n  ExhaustMapSubscriber.prototype.tryNext = function (value) {\n    var index = this.index++;\n    var destination = this.destination;\n\n    try {\n      var result = this.project(value, index);\n      this.hasSubscription = true;\n      this.add(subscribeToResult(this, result, value, index));\n    } catch (err) {\n      destination.error(err);\n    }\n  };\n\n  ExhaustMapSubscriber.prototype._complete = function () {\n    this.hasCompleted = true;\n\n    if (!this.hasSubscription) {\n      this.destination.complete();\n    }\n  };\n\n  ExhaustMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.destination.next(innerValue);\n  };\n\n  ExhaustMapSubscriber.prototype.notifyError = function (err) {\n    this.destination.error(err);\n  };\n\n  ExhaustMapSubscriber.prototype.notifyComplete = function (innerSub) {\n    this.remove(innerSub);\n    this.hasSubscription = false;\n\n    if (this.hasCompleted) {\n      this.destination.complete();\n    }\n  };\n\n  return ExhaustMapSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START tslib,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\n\n\nvar ExpandSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(ExpandSubscriber, _super);\n\n  function ExpandSubscriber(destination, project, concurrent, scheduler) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.project = project;\n    _this.concurrent = concurrent;\n    _this.scheduler = scheduler;\n    _this.index = 0;\n    _this.active = 0;\n    _this.hasCompleted = false;\n\n    if (concurrent < Number.POSITIVE_INFINITY) {\n      _this.buffer = [];\n    }\n\n    return _this;\n  }\n\n  ExpandSubscriber.dispatch = function (arg) {\n    var subscriber = arg.subscriber,\n        result = arg.result,\n        value = arg.value,\n        index = arg.index;\n    subscriber.subscribeToProjection(result, value, index);\n  };\n\n  ExpandSubscriber.prototype._next = function (value) {\n    var destination = this.destination;\n\n    if (destination.closed) {\n      this._complete();\n\n      return;\n    }\n\n    var index = this.index++;\n\n    if (this.active < this.concurrent) {\n      destination.next(value);\n      var result = tryCatch(this.project)(value, index);\n\n      if (result === errorObject) {\n        destination.error(errorObject.e);\n      } else if (!this.scheduler) {\n        this.subscribeToProjection(result, value, index);\n      } else {\n        var state = {\n          subscriber: this,\n          result: result,\n          value: value,\n          index: index\n        };\n        this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n      }\n    } else {\n      this.buffer.push(value);\n    }\n  };\n\n  ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {\n    this.active++;\n    this.add(subscribeToResult(this, result, value, index));\n  };\n\n  ExpandSubscriber.prototype._complete = function () {\n    this.hasCompleted = true;\n\n    if (this.hasCompleted && this.active === 0) {\n      this.destination.complete();\n    }\n  };\n\n  ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this._next(innerValue);\n  };\n\n  ExpandSubscriber.prototype.notifyComplete = function (innerSub) {\n    var buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n\n    if (buffer && buffer.length > 0) {\n      this._next(buffer.shift());\n    }\n\n    if (this.hasCompleted && this.active === 0) {\n      this.destination.complete();\n    }\n  };\n\n  return ExpandSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */\n\n\nvar FinallySubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(FinallySubscriber, _super);\n\n  function FinallySubscriber(destination, callback) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.add(new Subscription(callback));\n\n    return _this;\n  }\n\n  return FinallySubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nvar FindValueSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(FindValueSubscriber, _super);\n\n  function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.predicate = predicate;\n    _this.source = source;\n    _this.yieldIndex = yieldIndex;\n    _this.thisArg = thisArg;\n    _this.index = 0;\n    return _this;\n  }\n\n  FindValueSubscriber.prototype.notifyComplete = function (value) {\n    var destination = this.destination;\n    destination.next(value);\n    destination.complete();\n  };\n\n  FindValueSubscriber.prototype._next = function (value) {\n    var _a = this,\n        predicate = _a.predicate,\n        thisArg = _a.thisArg;\n\n    var index = this.index++;\n\n    try {\n      var result = predicate.call(thisArg || this, value, index, this.source);\n\n      if (result) {\n        this.notifyComplete(this.yieldIndex ? index : value);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  };\n\n  FindValueSubscriber.prototype._complete = function () {\n    this.notifyComplete(this.yieldIndex ? -1 : undefined);\n  };\n\n  return FindValueSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START _operators_find PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _util_EmptyError,_filter,_take,_defaultIfEmpty,_throwIfEmpty,_util_identity PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START tslib PURE_IMPORTS_END */\n\n\nvar ObjectUnsubscribedError =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(ObjectUnsubscribedError, _super);\n\n  function ObjectUnsubscribedError() {\n    var _this = _super.call(this, 'object unsubscribed') || this;\n\n    _this.name = 'ObjectUnsubscribedError';\n    Object.setPrototypeOf(_this, ObjectUnsubscribedError.prototype);\n    return _this;\n  }\n\n  return ObjectUnsubscribedError;\n}(Error);\n/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */\n\n\nvar SubjectSubscription =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(SubjectSubscription, _super);\n\n  function SubjectSubscription(subject, subscriber) {\n    var _this = _super.call(this) || this;\n\n    _this.subject = subject;\n    _this.subscriber = subscriber;\n    _this.closed = false;\n    return _this;\n  }\n\n  SubjectSubscription.prototype.unsubscribe = function () {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n    var subject = this.subject;\n    var observers = subject.observers;\n    this.subject = null;\n\n    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n      return;\n    }\n\n    var subscriberIndex = observers.indexOf(this.subscriber);\n\n    if (subscriberIndex !== -1) {\n      observers.splice(subscriberIndex, 1);\n    }\n  };\n\n  return SubjectSubscription;\n}(Subscription);\n/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */\n\n\nvar SubjectSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(SubjectSubscriber, _super);\n\n  function SubjectSubscriber(destination) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.destination = destination;\n    return _this;\n  }\n\n  return SubjectSubscriber;\n}(Subscriber);\n\nvar Subject =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(Subject, _super);\n\n  function Subject() {\n    var _this = _super.call(this) || this;\n\n    _this.observers = [];\n    _this.closed = false;\n    _this.isStopped = false;\n    _this.hasError = false;\n    _this.thrownError = null;\n    return _this;\n  }\n\n  Subject.prototype[rxSubscriber] = function () {\n    return new SubjectSubscriber(this);\n  };\n\n  Subject.prototype.lift = function (operator) {\n    var subject = new AnonymousSubject(this, this);\n    subject.operator = operator;\n    return subject;\n  };\n\n  Subject.prototype.next = function (value) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n\n    if (!this.isStopped) {\n      var observers = this.observers;\n      var len = observers.length;\n      var copy = observers.slice();\n\n      for (var i = 0; i < len; i++) {\n        copy[i].next(value);\n      }\n    }\n  };\n\n  Subject.prototype.error = function (err) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n\n    this.hasError = true;\n    this.thrownError = err;\n    this.isStopped = true;\n    var observers = this.observers;\n    var len = observers.length;\n    var copy = observers.slice();\n\n    for (var i = 0; i < len; i++) {\n      copy[i].error(err);\n    }\n\n    this.observers.length = 0;\n  };\n\n  Subject.prototype.complete = function () {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n\n    this.isStopped = true;\n    var observers = this.observers;\n    var len = observers.length;\n    var copy = observers.slice();\n\n    for (var i = 0; i < len; i++) {\n      copy[i].complete();\n    }\n\n    this.observers.length = 0;\n  };\n\n  Subject.prototype.unsubscribe = function () {\n    this.isStopped = true;\n    this.closed = true;\n    this.observers = null;\n  };\n\n  Subject.prototype._trySubscribe = function (subscriber) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else {\n      return _super.prototype._trySubscribe.call(this, subscriber);\n    }\n  };\n\n  Subject.prototype._subscribe = function (subscriber) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.hasError) {\n      subscriber.error(this.thrownError);\n      return Subscription.EMPTY;\n    } else if (this.isStopped) {\n      subscriber.complete();\n      return Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      return new SubjectSubscription(this, subscriber);\n    }\n  };\n\n  Subject.prototype.asObservable = function () {\n    var observable = new Observable();\n    observable.source = this;\n    return observable;\n  };\n\n  Subject.create = function (destination, source) {\n    return new AnonymousSubject(destination, source);\n  };\n\n  return Subject;\n}(Observable);\n\nvar AnonymousSubject =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(AnonymousSubject, _super);\n\n  function AnonymousSubject(destination, source) {\n    var _this = _super.call(this) || this;\n\n    _this.destination = destination;\n    _this.source = source;\n    return _this;\n  }\n\n  AnonymousSubject.prototype.next = function (value) {\n    var destination = this.destination;\n\n    if (destination && destination.next) {\n      destination.next(value);\n    }\n  };\n\n  AnonymousSubject.prototype.error = function (err) {\n    var destination = this.destination;\n\n    if (destination && destination.error) {\n      this.destination.error(err);\n    }\n  };\n\n  AnonymousSubject.prototype.complete = function () {\n    var destination = this.destination;\n\n    if (destination && destination.complete) {\n      this.destination.complete();\n    }\n  };\n\n  AnonymousSubject.prototype._subscribe = function (subscriber) {\n    var source = this.source;\n\n    if (source) {\n      return this.source.subscribe(subscriber);\n    } else {\n      return Subscription.EMPTY;\n    }\n  };\n\n  return AnonymousSubject;\n}(Subject);\n/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription,_Observable,_Subject PURE_IMPORTS_END */\n\n\nvar GroupBySubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(GroupBySubscriber, _super);\n\n  function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.keySelector = keySelector;\n    _this.elementSelector = elementSelector;\n    _this.durationSelector = durationSelector;\n    _this.subjectSelector = subjectSelector;\n    _this.groups = null;\n    _this.attemptedToUnsubscribe = false;\n    _this.count = 0;\n    return _this;\n  }\n\n  GroupBySubscriber.prototype._next = function (value) {\n    var key;\n\n    try {\n      key = this.keySelector(value);\n    } catch (err) {\n      this.error(err);\n      return;\n    }\n\n    this._group(value, key);\n  };\n\n  GroupBySubscriber.prototype._group = function (value, key) {\n    var groups = this.groups;\n\n    if (!groups) {\n      groups = this.groups = new Map();\n    }\n\n    var group = groups.get(key);\n    var element;\n\n    if (this.elementSelector) {\n      try {\n        element = this.elementSelector(value);\n      } catch (err) {\n        this.error(err);\n      }\n    } else {\n      element = value;\n    }\n\n    if (!group) {\n      group = this.subjectSelector ? this.subjectSelector() : new Subject();\n      groups.set(key, group);\n      var groupedObservable = new GroupedObservable(key, group, this);\n      this.destination.next(groupedObservable);\n\n      if (this.durationSelector) {\n        var duration = void 0;\n\n        try {\n          duration = this.durationSelector(new GroupedObservable(key, group));\n        } catch (err) {\n          this.error(err);\n          return;\n        }\n\n        this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));\n      }\n    }\n\n    if (!group.closed) {\n      group.next(element);\n    }\n  };\n\n  GroupBySubscriber.prototype._error = function (err) {\n    var groups = this.groups;\n\n    if (groups) {\n      groups.forEach(function (group, key) {\n        group.error(err);\n      });\n      groups.clear();\n    }\n\n    this.destination.error(err);\n  };\n\n  GroupBySubscriber.prototype._complete = function () {\n    var groups = this.groups;\n\n    if (groups) {\n      groups.forEach(function (group, key) {\n        group.complete();\n      });\n      groups.clear();\n    }\n\n    this.destination.complete();\n  };\n\n  GroupBySubscriber.prototype.removeGroup = function (key) {\n    this.groups.delete(key);\n  };\n\n  GroupBySubscriber.prototype.unsubscribe = function () {\n    if (!this.closed) {\n      this.attemptedToUnsubscribe = true;\n\n      if (this.count === 0) {\n        _super.prototype.unsubscribe.call(this);\n      }\n    }\n  };\n\n  return GroupBySubscriber;\n}(Subscriber);\n\nvar GroupDurationSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(GroupDurationSubscriber, _super);\n\n  function GroupDurationSubscriber(key, group, parent) {\n    var _this = _super.call(this, group) || this;\n\n    _this.key = key;\n    _this.group = group;\n    _this.parent = parent;\n    return _this;\n  }\n\n  GroupDurationSubscriber.prototype._next = function (value) {\n    this.complete();\n  };\n\n  GroupDurationSubscriber.prototype._unsubscribe = function () {\n    var _a = this,\n        parent = _a.parent,\n        key = _a.key;\n\n    this.key = this.parent = null;\n\n    if (parent) {\n      parent.removeGroup(key);\n    }\n  };\n\n  return GroupDurationSubscriber;\n}(Subscriber);\n\nvar GroupedObservable =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(GroupedObservable, _super);\n\n  function GroupedObservable(key, groupSubject, refCountSubscription) {\n    var _this = _super.call(this) || this;\n\n    _this.key = key;\n    _this.groupSubject = groupSubject;\n    _this.refCountSubscription = refCountSubscription;\n    return _this;\n  }\n\n  GroupedObservable.prototype._subscribe = function (subscriber) {\n    var subscription = new Subscription();\n\n    var _a = this,\n        refCountSubscription = _a.refCountSubscription,\n        groupSubject = _a.groupSubject;\n\n    if (refCountSubscription && !refCountSubscription.closed) {\n      subscription.add(new InnerRefCountSubscription(refCountSubscription));\n    }\n\n    subscription.add(groupSubject.subscribe(subscriber));\n    return subscription;\n  };\n\n  return GroupedObservable;\n}(Observable);\n\nvar InnerRefCountSubscription =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(InnerRefCountSubscription, _super);\n\n  function InnerRefCountSubscription(parent) {\n    var _this = _super.call(this) || this;\n\n    _this.parent = parent;\n    parent.count++;\n    return _this;\n  }\n\n  InnerRefCountSubscription.prototype.unsubscribe = function () {\n    var parent = this.parent;\n\n    if (!parent.closed && !this.closed) {\n      _super.prototype.unsubscribe.call(this);\n\n      parent.count -= 1;\n\n      if (parent.count === 0 && parent.attemptedToUnsubscribe) {\n        parent.unsubscribe();\n      }\n    }\n  };\n\n  return InnerRefCountSubscription;\n}(Subscription);\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nvar IgnoreElementsSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(IgnoreElementsSubscriber, _super);\n\n  function IgnoreElementsSubscriber() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  IgnoreElementsSubscriber.prototype._next = function (unused) {};\n\n  return IgnoreElementsSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nvar IsEmptySubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(IsEmptySubscriber, _super);\n\n  function IsEmptySubscriber(destination) {\n    return _super.call(this, destination) || this;\n  }\n\n  IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {\n    var destination = this.destination;\n    destination.next(isEmpty);\n    destination.complete();\n  };\n\n  IsEmptySubscriber.prototype._next = function (value) {\n    this.notifyComplete(false);\n  };\n\n  IsEmptySubscriber.prototype._complete = function () {\n    this.notifyComplete(true);\n  };\n\n  return IsEmptySubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */\n\n\nvar TakeLastSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(TakeLastSubscriber, _super);\n\n  function TakeLastSubscriber(destination, total) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.total = total;\n    _this.ring = new Array();\n    _this.count = 0;\n    return _this;\n  }\n\n  TakeLastSubscriber.prototype._next = function (value) {\n    var ring = this.ring;\n    var total = this.total;\n    var count = this.count++;\n\n    if (ring.length < total) {\n      ring.push(value);\n    } else {\n      var index = count % total;\n      ring[index] = value;\n    }\n  };\n\n  TakeLastSubscriber.prototype._complete = function () {\n    var destination = this.destination;\n    var count = this.count;\n\n    if (count > 0) {\n      var total = this.count >= this.total ? this.total : this.count;\n      var ring = this.ring;\n\n      for (var i = 0; i < total; i++) {\n        var idx = count++ % total;\n        destination.next(ring[idx]);\n      }\n    }\n\n    destination.complete();\n  };\n\n  return TakeLastSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START _util_EmptyError,_filter,_takeLast,_throwIfEmpty,_defaultIfEmpty,_util_identity PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nvar MapToSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(MapToSubscriber, _super);\n\n  function MapToSubscriber(destination, value) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.value = value;\n    return _this;\n  }\n\n  MapToSubscriber.prototype._next = function (x) {\n    this.destination.next(this.value);\n  };\n\n  return MapToSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */\n\n\nvar MaterializeSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(MaterializeSubscriber, _super);\n\n  function MaterializeSubscriber(destination) {\n    return _super.call(this, destination) || this;\n  }\n\n  MaterializeSubscriber.prototype._next = function (value) {\n    this.destination.next(Notification.createNext(value));\n  };\n\n  MaterializeSubscriber.prototype._error = function (err) {\n    var destination = this.destination;\n    destination.next(Notification.createError(err));\n    destination.complete();\n  };\n\n  MaterializeSubscriber.prototype._complete = function () {\n    var destination = this.destination;\n    destination.next(Notification.createComplete());\n    destination.complete();\n  };\n\n  return MaterializeSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nvar ScanSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(ScanSubscriber, _super);\n\n  function ScanSubscriber(destination, accumulator, _seed, hasSeed) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.accumulator = accumulator;\n    _this._seed = _seed;\n    _this.hasSeed = hasSeed;\n    _this.index = 0;\n    return _this;\n  }\n\n  Object.defineProperty(ScanSubscriber.prototype, \"seed\", {\n    get: function get() {\n      return this._seed;\n    },\n    set: function set(value) {\n      this.hasSeed = true;\n      this._seed = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ScanSubscriber.prototype._next = function (value) {\n    if (!this.hasSeed) {\n      this.seed = value;\n      this.destination.next(value);\n    } else {\n      return this._tryNext(value);\n    }\n  };\n\n  ScanSubscriber.prototype._tryNext = function (value) {\n    var index = this.index++;\n    var result;\n\n    try {\n      result = this.accumulator(this.seed, value, index);\n    } catch (err) {\n      this.destination.error(err);\n    }\n\n    this.seed = result;\n    this.destination.next(result);\n  };\n\n  return ScanSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START _scan,_takeLast,_defaultIfEmpty,_util_pipe PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _observable_merge PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START tslib,_util_tryCatch,_util_errorObject,_util_subscribeToResult,_OuterSubscriber PURE_IMPORTS_END */\n\n\nvar MergeScanSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(MergeScanSubscriber, _super);\n\n  function MergeScanSubscriber(destination, accumulator, acc, concurrent) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.accumulator = accumulator;\n    _this.acc = acc;\n    _this.concurrent = concurrent;\n    _this.hasValue = false;\n    _this.hasCompleted = false;\n    _this.buffer = [];\n    _this.active = 0;\n    _this.index = 0;\n    return _this;\n  }\n\n  MergeScanSubscriber.prototype._next = function (value) {\n    if (this.active < this.concurrent) {\n      var index = this.index++;\n      var ish = tryCatch(this.accumulator)(this.acc, value);\n      var destination = this.destination;\n\n      if (ish === errorObject) {\n        destination.error(errorObject.e);\n      } else {\n        this.active++;\n\n        this._innerSub(ish, value, index);\n      }\n    } else {\n      this.buffer.push(value);\n    }\n  };\n\n  MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {\n    this.add(subscribeToResult(this, ish, value, index));\n  };\n\n  MergeScanSubscriber.prototype._complete = function () {\n    this.hasCompleted = true;\n\n    if (this.active === 0 && this.buffer.length === 0) {\n      if (this.hasValue === false) {\n        this.destination.next(this.acc);\n      }\n\n      this.destination.complete();\n    }\n  };\n\n  MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    var destination = this.destination;\n    this.acc = innerValue;\n    this.hasValue = true;\n    destination.next(innerValue);\n  };\n\n  MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {\n    var buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      if (this.hasValue === false) {\n        this.destination.next(this.acc);\n      }\n\n      this.destination.complete();\n    }\n  };\n\n  return MergeScanSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nfunction refCount() {\n  return function refCountOperatorFunction(source) {\n    return source.lift(new RefCountOperator(source));\n  };\n}\n\nvar RefCountOperator =\n/*@__PURE__*/\nfunction () {\n  function RefCountOperator(connectable) {\n    this.connectable = connectable;\n  }\n\n  RefCountOperator.prototype.call = function (subscriber, source) {\n    var connectable = this.connectable;\n    connectable._refCount++;\n    var refCounter = new RefCountSubscriber(subscriber, connectable);\n    var subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      refCounter.connection = connectable.connect();\n    }\n\n    return subscription;\n  };\n\n  return RefCountOperator;\n}();\n\nvar RefCountSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(RefCountSubscriber, _super);\n\n  function RefCountSubscriber(destination, connectable) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.connectable = connectable;\n    return _this;\n  }\n\n  RefCountSubscriber.prototype._unsubscribe = function () {\n    var connectable = this.connectable;\n\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    var refCount = connectable._refCount;\n\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    connectable._refCount = refCount - 1;\n\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    var connection = this.connection;\n    var sharedConnection = connectable._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  };\n\n  return RefCountSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */\n\n\nvar ConnectableObservable =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(ConnectableObservable, _super);\n\n  function ConnectableObservable(source, subjectFactory) {\n    var _this = _super.call(this) || this;\n\n    _this.source = source;\n    _this.subjectFactory = subjectFactory;\n    _this._refCount = 0;\n    _this._isComplete = false;\n    return _this;\n  }\n\n  ConnectableObservable.prototype._subscribe = function (subscriber) {\n    return this.getSubject().subscribe(subscriber);\n  };\n\n  ConnectableObservable.prototype.getSubject = function () {\n    var subject = this._subject;\n\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n\n    return this._subject;\n  };\n\n  ConnectableObservable.prototype.connect = function () {\n    var connection = this._connection;\n\n    if (!connection) {\n      this._isComplete = false;\n      connection = this._connection = new Subscription();\n      connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      } else {\n        this._connection = connection;\n      }\n    }\n\n    return connection;\n  };\n\n  ConnectableObservable.prototype.refCount = function () {\n    return refCount()(this);\n  };\n\n  return ConnectableObservable;\n}(Observable);\n\nvar connectableProto = ConnectableObservable.prototype;\nvar connectableObservableDescriptor = {\n  operator: {\n    value: null\n  },\n  _refCount: {\n    value: 0,\n    writable: true\n  },\n  _subject: {\n    value: null,\n    writable: true\n  },\n  _connection: {\n    value: null,\n    writable: true\n  },\n  _subscribe: {\n    value: connectableProto._subscribe\n  },\n  _isComplete: {\n    value: connectableProto._isComplete,\n    writable: true\n  },\n  getSubject: {\n    value: connectableProto.getSubject\n  },\n  connect: {\n    value: connectableProto.connect\n  },\n  refCount: {\n    value: connectableProto.refCount\n  }\n};\n\nvar ConnectableSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(ConnectableSubscriber, _super);\n\n  function ConnectableSubscriber(destination, connectable) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.connectable = connectable;\n    return _this;\n  }\n\n  ConnectableSubscriber.prototype._error = function (err) {\n    this._unsubscribe();\n\n    _super.prototype._error.call(this, err);\n  };\n\n  ConnectableSubscriber.prototype._complete = function () {\n    this.connectable._isComplete = true;\n\n    this._unsubscribe();\n\n    _super.prototype._complete.call(this);\n  };\n\n  ConnectableSubscriber.prototype._unsubscribe = function () {\n    var connectable = this.connectable;\n\n    if (connectable) {\n      this.connectable = null;\n      var connection = connectable._connection;\n      connectable._refCount = 0;\n      connectable._subject = null;\n      connectable._connection = null;\n\n      if (connection) {\n        connection.unsubscribe();\n      }\n    }\n  };\n\n  return ConnectableSubscriber;\n}(SubjectSubscriber);\n\nvar RefCountSubscriber$1 =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(RefCountSubscriber, _super);\n\n  function RefCountSubscriber(destination, connectable) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.connectable = connectable;\n    return _this;\n  }\n\n  RefCountSubscriber.prototype._unsubscribe = function () {\n    var connectable = this.connectable;\n\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    var refCount$$1 = connectable._refCount;\n\n    if (refCount$$1 <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    connectable._refCount = refCount$$1 - 1;\n\n    if (refCount$$1 > 1) {\n      this.connection = null;\n      return;\n    }\n\n    var connection = this.connection;\n    var sharedConnection = connectable._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  };\n\n  return RefCountSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */\n\n\nvar ObserveOnSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(ObserveOnSubscriber, _super);\n\n  function ObserveOnSubscriber(destination, scheduler, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    var _this = _super.call(this, destination) || this;\n\n    _this.scheduler = scheduler;\n    _this.delay = delay;\n    return _this;\n  }\n\n  ObserveOnSubscriber.dispatch = function (arg) {\n    var notification = arg.notification,\n        destination = arg.destination;\n    notification.observe(destination);\n    this.unsubscribe();\n  };\n\n  ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {\n    this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n  };\n\n  ObserveOnSubscriber.prototype._next = function (value) {\n    this.scheduleMessage(Notification.createNext(value));\n  };\n\n  ObserveOnSubscriber.prototype._error = function (err) {\n    this.scheduleMessage(Notification.createError(err));\n  };\n\n  ObserveOnSubscriber.prototype._complete = function () {\n    this.scheduleMessage(Notification.createComplete());\n  };\n\n  return ObserveOnSubscriber;\n}(Subscriber);\n\nvar ObserveOnMessage =\n/*@__PURE__*/\nfunction () {\n  function ObserveOnMessage(notification, destination) {\n    this.notification = notification;\n    this.destination = destination;\n  }\n\n  return ObserveOnMessage;\n}();\n/** PURE_IMPORTS_START tslib,_observable_from,_util_isArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\n\n\nvar OnErrorResumeNextSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(OnErrorResumeNextSubscriber, _super);\n\n  function OnErrorResumeNextSubscriber(destination, nextSources) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.destination = destination;\n    _this.nextSources = nextSources;\n    return _this;\n  }\n\n  OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {\n    this.subscribeToNextSource();\n  };\n\n  OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {\n    this.subscribeToNextSource();\n  };\n\n  OnErrorResumeNextSubscriber.prototype._error = function (err) {\n    this.subscribeToNextSource();\n  };\n\n  OnErrorResumeNextSubscriber.prototype._complete = function () {\n    this.subscribeToNextSource();\n  };\n\n  OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {\n    var next = this.nextSources.shift();\n\n    if (next) {\n      this.add(subscribeToResult(this, next));\n    } else {\n      this.destination.complete();\n    }\n  };\n\n  return OnErrorResumeNextSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nvar PairwiseSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(PairwiseSubscriber, _super);\n\n  function PairwiseSubscriber(destination) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.hasPrev = false;\n    return _this;\n  }\n\n  PairwiseSubscriber.prototype._next = function (value) {\n    if (this.hasPrev) {\n      this.destination.next([this.prev, value]);\n    } else {\n      this.hasPrev = true;\n    }\n\n    this.prev = value;\n  };\n\n  return PairwiseSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _util_not,_filter PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _map PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */\n\n\nvar BehaviorSubject =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(BehaviorSubject, _super);\n\n  function BehaviorSubject(_value) {\n    var _this = _super.call(this) || this;\n\n    _this._value = _value;\n    return _this;\n  }\n\n  Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n    get: function get() {\n      return this.getValue();\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  BehaviorSubject.prototype._subscribe = function (subscriber) {\n    var subscription = _super.prototype._subscribe.call(this, subscriber);\n\n    if (subscription && !subscription.closed) {\n      subscriber.next(this._value);\n    }\n\n    return subscription;\n  };\n\n  BehaviorSubject.prototype.getValue = function () {\n    if (this.hasError) {\n      throw this.thrownError;\n    } else if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else {\n      return this._value;\n    }\n  };\n\n  BehaviorSubject.prototype.next = function (value) {\n    _super.prototype.next.call(this, this._value = value);\n  };\n\n  return BehaviorSubject;\n}(Subject);\n/** PURE_IMPORTS_START _BehaviorSubject,_multicast PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */\n\n\nvar AsyncSubject =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(AsyncSubject, _super);\n\n  function AsyncSubject() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.value = null;\n    _this.hasNext = false;\n    _this.hasCompleted = false;\n    return _this;\n  }\n\n  AsyncSubject.prototype._subscribe = function (subscriber) {\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n      return Subscription.EMPTY;\n    } else if (this.hasCompleted && this.hasNext) {\n      subscriber.next(this.value);\n      subscriber.complete();\n      return Subscription.EMPTY;\n    }\n\n    return _super.prototype._subscribe.call(this, subscriber);\n  };\n\n  AsyncSubject.prototype.next = function (value) {\n    if (!this.hasCompleted) {\n      this.value = value;\n      this.hasNext = true;\n    }\n  };\n\n  AsyncSubject.prototype.error = function (error) {\n    if (!this.hasCompleted) {\n      _super.prototype.error.call(this, error);\n    }\n  };\n\n  AsyncSubject.prototype.complete = function () {\n    this.hasCompleted = true;\n\n    if (this.hasNext) {\n      _super.prototype.next.call(this, this.value);\n    }\n\n    _super.prototype.complete.call(this);\n  };\n\n  return AsyncSubject;\n}(Subject);\n/** PURE_IMPORTS_START _AsyncSubject,_multicast PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */\n\n\nvar QueueAction =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(QueueAction, _super);\n\n  function QueueAction(scheduler, work) {\n    var _this = _super.call(this, scheduler, work) || this;\n\n    _this.scheduler = scheduler;\n    _this.work = work;\n    return _this;\n  }\n\n  QueueAction.prototype.schedule = function (state, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (delay > 0) {\n      return _super.prototype.schedule.call(this, state, delay);\n    }\n\n    this.delay = delay;\n    this.state = state;\n    this.scheduler.flush(this);\n    return this;\n  };\n\n  QueueAction.prototype.execute = function (state, delay) {\n    return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);\n  };\n\n  QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {\n      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n    }\n\n    return scheduler.flush(this);\n  };\n\n  return QueueAction;\n}(AsyncAction);\n/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */\n\n\nvar QueueScheduler =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(QueueScheduler, _super);\n\n  function QueueScheduler() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return QueueScheduler;\n}(AsyncScheduler);\n/** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */\n\n\nvar queue =\n/*@__PURE__*/\nnew QueueScheduler(QueueAction);\n/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */\n\nvar ReplaySubject =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(ReplaySubject, _super);\n\n  function ReplaySubject(bufferSize, windowTime, scheduler) {\n    if (bufferSize === void 0) {\n      bufferSize = Number.POSITIVE_INFINITY;\n    }\n\n    if (windowTime === void 0) {\n      windowTime = Number.POSITIVE_INFINITY;\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.scheduler = scheduler;\n    _this._events = [];\n    _this._infiniteTimeWindow = false;\n    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    _this._windowTime = windowTime < 1 ? 1 : windowTime;\n\n    if (windowTime === Number.POSITIVE_INFINITY) {\n      _this._infiniteTimeWindow = true;\n      _this.next = _this.nextInfiniteTimeWindow;\n    } else {\n      _this.next = _this.nextTimeWindow;\n    }\n\n    return _this;\n  }\n\n  ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {\n    var _events = this._events;\n\n    _events.push(value);\n\n    if (_events.length > this._bufferSize) {\n      _events.shift();\n    }\n\n    _super.prototype.next.call(this, value);\n  };\n\n  ReplaySubject.prototype.nextTimeWindow = function (value) {\n    this._events.push(new ReplayEvent(this._getNow(), value));\n\n    this._trimBufferThenGetEvents();\n\n    _super.prototype.next.call(this, value);\n  };\n\n  ReplaySubject.prototype._subscribe = function (subscriber) {\n    var _infiniteTimeWindow = this._infiniteTimeWindow;\n\n    var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n\n    var scheduler = this.scheduler;\n    var len = _events.length;\n    var subscription;\n\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.isStopped || this.hasError) {\n      subscription = Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      subscription = new SubjectSubscription(this, subscriber);\n    }\n\n    if (scheduler) {\n      subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n    }\n\n    if (_infiniteTimeWindow) {\n      for (var i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(_events[i]);\n      }\n    } else {\n      for (var i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(_events[i].value);\n      }\n    }\n\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n    } else if (this.isStopped) {\n      subscriber.complete();\n    }\n\n    return subscription;\n  };\n\n  ReplaySubject.prototype._getNow = function () {\n    return (this.scheduler || queue).now();\n  };\n\n  ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n    var now = this._getNow();\n\n    var _bufferSize = this._bufferSize;\n    var _windowTime = this._windowTime;\n    var _events = this._events;\n    var eventsCount = _events.length;\n    var spliceCount = 0;\n\n    while (spliceCount < eventsCount) {\n      if (now - _events[spliceCount].time < _windowTime) {\n        break;\n      }\n\n      spliceCount++;\n    }\n\n    if (eventsCount > _bufferSize) {\n      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n    }\n\n    if (spliceCount > 0) {\n      _events.splice(0, spliceCount);\n    }\n\n    return _events;\n  };\n\n  return ReplaySubject;\n}(Subject);\n\nvar ReplayEvent =\n/*@__PURE__*/\nfunction () {\n  function ReplayEvent(time, value) {\n    this.time = time;\n    this.value = value;\n  }\n\n  return ReplayEvent;\n}();\n/** PURE_IMPORTS_START _ReplaySubject,_multicast PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\n\n\nvar RaceSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(RaceSubscriber, _super);\n\n  function RaceSubscriber(destination) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.hasFirst = false;\n    _this.observables = [];\n    _this.subscriptions = [];\n    return _this;\n  }\n\n  RaceSubscriber.prototype._next = function (observable) {\n    this.observables.push(observable);\n  };\n\n  RaceSubscriber.prototype._complete = function () {\n    var observables = this.observables;\n    var len = observables.length;\n\n    if (len === 0) {\n      this.destination.complete();\n    } else {\n      for (var i = 0; i < len && !this.hasFirst; i++) {\n        var observable = observables[i];\n        var subscription = subscribeToResult(this, observable, observable, i);\n\n        if (this.subscriptions) {\n          this.subscriptions.push(subscription);\n        }\n\n        this.add(subscription);\n      }\n\n      this.observables = null;\n    }\n  };\n\n  RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    if (!this.hasFirst) {\n      this.hasFirst = true;\n\n      for (var i = 0; i < this.subscriptions.length; i++) {\n        if (i !== outerIndex) {\n          var subscription = this.subscriptions[i];\n          subscription.unsubscribe();\n          this.remove(subscription);\n        }\n      }\n\n      this.subscriptions = null;\n    }\n\n    this.destination.next(innerValue);\n  };\n\n  return RaceSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START _util_isArray,_observable_race PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START tslib,_Subscriber,_observable_empty PURE_IMPORTS_END */\n\n\nvar RepeatSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(RepeatSubscriber, _super);\n\n  function RepeatSubscriber(destination, count, source) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.count = count;\n    _this.source = source;\n    return _this;\n  }\n\n  RepeatSubscriber.prototype.complete = function () {\n    if (!this.isStopped) {\n      var _a = this,\n          source = _a.source,\n          count = _a.count;\n\n      if (count === 0) {\n        return _super.prototype.complete.call(this);\n      } else if (count > -1) {\n        this.count = count - 1;\n      }\n\n      source.subscribe(this._unsubscribeAndRecycle());\n    }\n  };\n\n  return RepeatSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_Subject,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\n\n\nvar RepeatWhenSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(RepeatWhenSubscriber, _super);\n\n  function RepeatWhenSubscriber(destination, notifier, source) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.notifier = notifier;\n    _this.source = source;\n    _this.sourceIsBeingSubscribedTo = true;\n    return _this;\n  }\n\n  RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.sourceIsBeingSubscribedTo = true;\n    this.source.subscribe(this);\n  };\n\n  RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {\n    if (this.sourceIsBeingSubscribedTo === false) {\n      return _super.prototype.complete.call(this);\n    }\n  };\n\n  RepeatWhenSubscriber.prototype.complete = function () {\n    this.sourceIsBeingSubscribedTo = false;\n\n    if (!this.isStopped) {\n      if (!this.retries) {\n        this.subscribeToRetries();\n      }\n\n      if (!this.retriesSubscription || this.retriesSubscription.closed) {\n        return _super.prototype.complete.call(this);\n      }\n\n      this._unsubscribeAndRecycle();\n\n      this.notifications.next();\n    }\n  };\n\n  RepeatWhenSubscriber.prototype._unsubscribe = function () {\n    var _a = this,\n        notifications = _a.notifications,\n        retriesSubscription = _a.retriesSubscription;\n\n    if (notifications) {\n      notifications.unsubscribe();\n      this.notifications = null;\n    }\n\n    if (retriesSubscription) {\n      retriesSubscription.unsubscribe();\n      this.retriesSubscription = null;\n    }\n\n    this.retries = null;\n  };\n\n  RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {\n    var _unsubscribe = this._unsubscribe;\n    this._unsubscribe = null;\n\n    _super.prototype._unsubscribeAndRecycle.call(this);\n\n    this._unsubscribe = _unsubscribe;\n    return this;\n  };\n\n  RepeatWhenSubscriber.prototype.subscribeToRetries = function () {\n    this.notifications = new Subject();\n    var retries = tryCatch(this.notifier)(this.notifications);\n\n    if (retries === errorObject) {\n      return _super.prototype.complete.call(this);\n    }\n\n    this.retries = retries;\n    this.retriesSubscription = subscribeToResult(this, retries);\n  };\n\n  return RepeatWhenSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nvar RetrySubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(RetrySubscriber, _super);\n\n  function RetrySubscriber(destination, count, source) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.count = count;\n    _this.source = source;\n    return _this;\n  }\n\n  RetrySubscriber.prototype.error = function (err) {\n    if (!this.isStopped) {\n      var _a = this,\n          source = _a.source,\n          count = _a.count;\n\n      if (count === 0) {\n        return _super.prototype.error.call(this, err);\n      } else if (count > -1) {\n        this.count = count - 1;\n      }\n\n      source.subscribe(this._unsubscribeAndRecycle());\n    }\n  };\n\n  return RetrySubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_Subject,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\n\n\nvar RetryWhenSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(RetryWhenSubscriber, _super);\n\n  function RetryWhenSubscriber(destination, notifier, source) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.notifier = notifier;\n    _this.source = source;\n    return _this;\n  }\n\n  RetryWhenSubscriber.prototype.error = function (err) {\n    if (!this.isStopped) {\n      var errors = this.errors;\n      var retries = this.retries;\n      var retriesSubscription = this.retriesSubscription;\n\n      if (!retries) {\n        errors = new Subject();\n        retries = tryCatch(this.notifier)(errors);\n\n        if (retries === errorObject) {\n          return _super.prototype.error.call(this, errorObject.e);\n        }\n\n        retriesSubscription = subscribeToResult(this, retries);\n      } else {\n        this.errors = null;\n        this.retriesSubscription = null;\n      }\n\n      this._unsubscribeAndRecycle();\n\n      this.errors = errors;\n      this.retries = retries;\n      this.retriesSubscription = retriesSubscription;\n      errors.next(err);\n    }\n  };\n\n  RetryWhenSubscriber.prototype._unsubscribe = function () {\n    var _a = this,\n        errors = _a.errors,\n        retriesSubscription = _a.retriesSubscription;\n\n    if (errors) {\n      errors.unsubscribe();\n      this.errors = null;\n    }\n\n    if (retriesSubscription) {\n      retriesSubscription.unsubscribe();\n      this.retriesSubscription = null;\n    }\n\n    this.retries = null;\n  };\n\n  RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    var _unsubscribe = this._unsubscribe;\n    this._unsubscribe = null;\n\n    this._unsubscribeAndRecycle();\n\n    this._unsubscribe = _unsubscribe;\n    this.source.subscribe(this);\n  };\n\n  return RetryWhenSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\n\n\nvar SampleSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(SampleSubscriber, _super);\n\n  function SampleSubscriber() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.hasValue = false;\n    return _this;\n  }\n\n  SampleSubscriber.prototype._next = function (value) {\n    this.value = value;\n    this.hasValue = true;\n  };\n\n  SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.emitValue();\n  };\n\n  SampleSubscriber.prototype.notifyComplete = function () {\n    this.emitValue();\n  };\n\n  SampleSubscriber.prototype.emitValue = function () {\n    if (this.hasValue) {\n      this.hasValue = false;\n      this.destination.next(this.value);\n    }\n  };\n\n  return SampleSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */\n\n\nvar SampleTimeSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(SampleTimeSubscriber, _super);\n\n  function SampleTimeSubscriber(destination, period, scheduler) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.period = period;\n    _this.scheduler = scheduler;\n    _this.hasValue = false;\n\n    _this.add(scheduler.schedule(dispatchNotification, period, {\n      subscriber: _this,\n      period: period\n    }));\n\n    return _this;\n  }\n\n  SampleTimeSubscriber.prototype._next = function (value) {\n    this.lastValue = value;\n    this.hasValue = true;\n  };\n\n  SampleTimeSubscriber.prototype.notifyNext = function () {\n    if (this.hasValue) {\n      this.hasValue = false;\n      this.destination.next(this.lastValue);\n    }\n  };\n\n  return SampleTimeSubscriber;\n}(Subscriber);\n\nfunction dispatchNotification(state) {\n  var subscriber = state.subscriber,\n      period = state.period;\n  subscriber.notifyNext();\n  this.schedule(state, period);\n}\n/** PURE_IMPORTS_START tslib,_Subscriber,_util_tryCatch,_util_errorObject PURE_IMPORTS_END */\n\n\nvar SequenceEqualSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(SequenceEqualSubscriber, _super);\n\n  function SequenceEqualSubscriber(destination, compareTo, comparor) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.compareTo = compareTo;\n    _this.comparor = comparor;\n    _this._a = [];\n    _this._b = [];\n    _this._oneComplete = false;\n\n    _this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));\n\n    return _this;\n  }\n\n  SequenceEqualSubscriber.prototype._next = function (value) {\n    if (this._oneComplete && this._b.length === 0) {\n      this.emit(false);\n    } else {\n      this._a.push(value);\n\n      this.checkValues();\n    }\n  };\n\n  SequenceEqualSubscriber.prototype._complete = function () {\n    if (this._oneComplete) {\n      this.emit(this._a.length === 0 && this._b.length === 0);\n    } else {\n      this._oneComplete = true;\n    }\n  };\n\n  SequenceEqualSubscriber.prototype.checkValues = function () {\n    var _c = this,\n        _a = _c._a,\n        _b = _c._b,\n        comparor = _c.comparor;\n\n    while (_a.length > 0 && _b.length > 0) {\n      var a = _a.shift();\n\n      var b = _b.shift();\n\n      var areEqual = false;\n\n      if (comparor) {\n        areEqual = tryCatch(comparor)(a, b);\n\n        if (areEqual === errorObject) {\n          this.destination.error(errorObject.e);\n        }\n      } else {\n        areEqual = a === b;\n      }\n\n      if (!areEqual) {\n        this.emit(false);\n      }\n    }\n  };\n\n  SequenceEqualSubscriber.prototype.emit = function (value) {\n    var destination = this.destination;\n    destination.next(value);\n    destination.complete();\n  };\n\n  SequenceEqualSubscriber.prototype.nextB = function (value) {\n    if (this._oneComplete && this._a.length === 0) {\n      this.emit(false);\n    } else {\n      this._b.push(value);\n\n      this.checkValues();\n    }\n  };\n\n  return SequenceEqualSubscriber;\n}(Subscriber);\n\nvar SequenceEqualCompareToSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(SequenceEqualCompareToSubscriber, _super);\n\n  function SequenceEqualCompareToSubscriber(destination, parent) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.parent = parent;\n    return _this;\n  }\n\n  SequenceEqualCompareToSubscriber.prototype._next = function (value) {\n    this.parent.nextB(value);\n  };\n\n  SequenceEqualCompareToSubscriber.prototype._error = function (err) {\n    this.parent.error(err);\n  };\n\n  SequenceEqualCompareToSubscriber.prototype._complete = function () {\n    this.parent._complete();\n  };\n\n  return SequenceEqualCompareToSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _ReplaySubject PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START tslib,_Subscriber,_util_EmptyError PURE_IMPORTS_END */\n\n\nvar SingleSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(SingleSubscriber, _super);\n\n  function SingleSubscriber(destination, predicate, source) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.predicate = predicate;\n    _this.source = source;\n    _this.seenValue = false;\n    _this.index = 0;\n    return _this;\n  }\n\n  SingleSubscriber.prototype.applySingleValue = function (value) {\n    if (this.seenValue) {\n      this.destination.error('Sequence contains more than one element');\n    } else {\n      this.seenValue = true;\n      this.singleValue = value;\n    }\n  };\n\n  SingleSubscriber.prototype._next = function (value) {\n    var index = this.index++;\n\n    if (this.predicate) {\n      this.tryNext(value, index);\n    } else {\n      this.applySingleValue(value);\n    }\n  };\n\n  SingleSubscriber.prototype.tryNext = function (value, index) {\n    try {\n      if (this.predicate(value, index, this.source)) {\n        this.applySingleValue(value);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  };\n\n  SingleSubscriber.prototype._complete = function () {\n    var destination = this.destination;\n\n    if (this.index > 0) {\n      destination.next(this.seenValue ? this.singleValue : undefined);\n      destination.complete();\n    } else {\n      destination.error(new EmptyError());\n    }\n  };\n\n  return SingleSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nvar SkipSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(SkipSubscriber, _super);\n\n  function SkipSubscriber(destination, total) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.total = total;\n    _this.count = 0;\n    return _this;\n  }\n\n  SkipSubscriber.prototype._next = function (x) {\n    if (++this.count > this.total) {\n      this.destination.next(x);\n    }\n  };\n\n  return SkipSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError PURE_IMPORTS_END */\n\n\nvar SkipLastSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(SkipLastSubscriber, _super);\n\n  function SkipLastSubscriber(destination, _skipCount) {\n    var _this = _super.call(this, destination) || this;\n\n    _this._skipCount = _skipCount;\n    _this._count = 0;\n    _this._ring = new Array(_skipCount);\n    return _this;\n  }\n\n  SkipLastSubscriber.prototype._next = function (value) {\n    var skipCount = this._skipCount;\n    var count = this._count++;\n\n    if (count < skipCount) {\n      this._ring[count] = value;\n    } else {\n      var currentIndex = count % skipCount;\n      var ring = this._ring;\n      var oldValue = ring[currentIndex];\n      ring[currentIndex] = value;\n      this.destination.next(oldValue);\n    }\n  };\n\n  return SkipLastSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\n\n\nvar SkipUntilSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(SkipUntilSubscriber, _super);\n\n  function SkipUntilSubscriber(destination, notifier) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.hasValue = false;\n\n    _this.add(_this.innerSubscription = subscribeToResult(_this, notifier));\n\n    return _this;\n  }\n\n  SkipUntilSubscriber.prototype._next = function (value) {\n    if (this.hasValue) {\n      _super.prototype._next.call(this, value);\n    }\n  };\n\n  SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.hasValue = true;\n\n    if (this.innerSubscription) {\n      this.innerSubscription.unsubscribe();\n    }\n  };\n\n  SkipUntilSubscriber.prototype.notifyComplete = function () {};\n\n  return SkipUntilSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nvar SkipWhileSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(SkipWhileSubscriber, _super);\n\n  function SkipWhileSubscriber(destination, predicate) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.predicate = predicate;\n    _this.skipping = true;\n    _this.index = 0;\n    return _this;\n  }\n\n  SkipWhileSubscriber.prototype._next = function (value) {\n    var destination = this.destination;\n\n    if (this.skipping) {\n      this.tryCallPredicate(value);\n    }\n\n    if (!this.skipping) {\n      destination.next(value);\n    }\n  };\n\n  SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {\n    try {\n      var result = this.predicate(value, this.index++);\n      this.skipping = Boolean(result);\n    } catch (err) {\n      this.destination.error(err);\n    }\n  };\n\n  return SkipWhileSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START _observable_fromArray,_observable_scalar,_observable_empty,_observable_concat,_util_isScheduler PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar nextHandle = 1;\nvar tasksByHandle = {};\n\nfunction runIfPresent(handle) {\n  var cb = tasksByHandle[handle];\n\n  if (cb) {\n    cb();\n  }\n}\n\nvar Immediate = {\n  setImmediate: function setImmediate(cb) {\n    var handle = nextHandle++;\n    tasksByHandle[handle] = cb;\n    Promise.resolve().then(function () {\n      return runIfPresent(handle);\n    });\n    return handle;\n  },\n  clearImmediate: function clearImmediate(handle) {\n    delete tasksByHandle[handle];\n  }\n};\n/** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */\n\nvar AsapAction =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(AsapAction, _super);\n\n  function AsapAction(scheduler, work) {\n    var _this = _super.call(this, scheduler, work) || this;\n\n    _this.scheduler = scheduler;\n    _this.work = work;\n    return _this;\n  }\n\n  AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (delay !== null && delay > 0) {\n      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n    }\n\n    scheduler.actions.push(this);\n    return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));\n  };\n\n  AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {\n      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n    }\n\n    if (scheduler.actions.length === 0) {\n      Immediate.clearImmediate(id);\n      scheduler.scheduled = undefined;\n    }\n\n    return undefined;\n  };\n\n  return AsapAction;\n}(AsyncAction);\n/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */\n\n\nvar AsapScheduler =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(AsapScheduler, _super);\n\n  function AsapScheduler() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  AsapScheduler.prototype.flush = function (action) {\n    this.active = true;\n    this.scheduled = undefined;\n    var actions = this.actions;\n    var error;\n    var index = -1;\n    var count = actions.length;\n    action = action || actions.shift();\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (++index < count && (action = actions.shift()));\n\n    this.active = false;\n\n    if (error) {\n      while (++index < count && (action = actions.shift())) {\n        action.unsubscribe();\n      }\n\n      throw error;\n    }\n  };\n\n  return AsapScheduler;\n}(AsyncScheduler);\n/** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */\n\n\nvar asap =\n/*@__PURE__*/\nnew AsapScheduler(AsapAction);\n/** PURE_IMPORTS_START tslib,_Observable,_scheduler_asap,_util_isNumeric PURE_IMPORTS_END */\n\nvar SubscribeOnObservable =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(SubscribeOnObservable, _super);\n\n  function SubscribeOnObservable(source, delayTime, scheduler) {\n    if (delayTime === void 0) {\n      delayTime = 0;\n    }\n\n    if (scheduler === void 0) {\n      scheduler = asap;\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.source = source;\n    _this.delayTime = delayTime;\n    _this.scheduler = scheduler;\n\n    if (!isNumeric(delayTime) || delayTime < 0) {\n      _this.delayTime = 0;\n    }\n\n    if (!scheduler || typeof scheduler.schedule !== 'function') {\n      _this.scheduler = asap;\n    }\n\n    return _this;\n  }\n\n  SubscribeOnObservable.create = function (source, delay, scheduler) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (scheduler === void 0) {\n      scheduler = asap;\n    }\n\n    return new SubscribeOnObservable(source, delay, scheduler);\n  };\n\n  SubscribeOnObservable.dispatch = function (arg) {\n    var source = arg.source,\n        subscriber = arg.subscriber;\n    return this.add(source.subscribe(subscriber));\n  };\n\n  SubscribeOnObservable.prototype._subscribe = function (subscriber) {\n    var delay = this.delayTime;\n    var source = this.source;\n    var scheduler = this.scheduler;\n    return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {\n      source: source,\n      subscriber: subscriber\n    });\n  };\n\n  return SubscribeOnObservable;\n}(Observable);\n/** PURE_IMPORTS_START _observable_SubscribeOnObservable PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */\n\n\nvar SwitchMapSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(SwitchMapSubscriber, _super);\n\n  function SwitchMapSubscriber(destination, project) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.project = project;\n    _this.index = 0;\n    return _this;\n  }\n\n  SwitchMapSubscriber.prototype._next = function (value) {\n    var result;\n    var index = this.index++;\n\n    try {\n      result = this.project(value, index);\n    } catch (error) {\n      this.destination.error(error);\n      return;\n    }\n\n    this._innerSub(result, value, index);\n  };\n\n  SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {\n    var innerSubscription = this.innerSubscription;\n\n    if (innerSubscription) {\n      innerSubscription.unsubscribe();\n    }\n\n    this.add(this.innerSubscription = subscribeToResult(this, result, value, index));\n  };\n\n  SwitchMapSubscriber.prototype._complete = function () {\n    var innerSubscription = this.innerSubscription;\n\n    if (!innerSubscription || innerSubscription.closed) {\n      _super.prototype._complete.call(this);\n    }\n  };\n\n  SwitchMapSubscriber.prototype._unsubscribe = function () {\n    this.innerSubscription = null;\n  };\n\n  SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {\n    this.remove(innerSub);\n    this.innerSubscription = null;\n\n    if (this.isStopped) {\n      _super.prototype._complete.call(this);\n    }\n  };\n\n  SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.destination.next(innerValue);\n  };\n\n  return SwitchMapSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START _switchMap,_util_identity PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\n\n\nvar TakeUntilSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(TakeUntilSubscriber, _super);\n\n  function TakeUntilSubscriber(destination) {\n    return _super.call(this, destination) || this;\n  }\n\n  TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.complete();\n  };\n\n  TakeUntilSubscriber.prototype.notifyComplete = function () {};\n\n  return TakeUntilSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nvar TakeWhileSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(TakeWhileSubscriber, _super);\n\n  function TakeWhileSubscriber(destination, predicate) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.predicate = predicate;\n    _this.index = 0;\n    return _this;\n  }\n\n  TakeWhileSubscriber.prototype._next = function (value) {\n    var destination = this.destination;\n    var result;\n\n    try {\n      result = this.predicate(value, this.index++);\n    } catch (err) {\n      destination.error(err);\n      return;\n    }\n\n    this.nextOrComplete(value, result);\n  };\n\n  TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {\n    var destination = this.destination;\n\n    if (Boolean(predicateResult)) {\n      destination.next(value);\n    } else {\n      destination.complete();\n    }\n  };\n\n  return TakeWhileSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\n\n\nvar ThrottleSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(ThrottleSubscriber, _super);\n\n  function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.destination = destination;\n    _this.durationSelector = durationSelector;\n    _this._leading = _leading;\n    _this._trailing = _trailing;\n    _this._hasValue = false;\n    return _this;\n  }\n\n  ThrottleSubscriber.prototype._next = function (value) {\n    this._hasValue = true;\n    this._sendValue = value;\n\n    if (!this._throttled) {\n      if (this._leading) {\n        this.send();\n      } else {\n        this.throttle(value);\n      }\n    }\n  };\n\n  ThrottleSubscriber.prototype.send = function () {\n    var _a = this,\n        _hasValue = _a._hasValue,\n        _sendValue = _a._sendValue;\n\n    if (_hasValue) {\n      this.destination.next(_sendValue);\n      this.throttle(_sendValue);\n    }\n\n    this._hasValue = false;\n    this._sendValue = null;\n  };\n\n  ThrottleSubscriber.prototype.throttle = function (value) {\n    var duration = this.tryDurationSelector(value);\n\n    if (duration) {\n      this.add(this._throttled = subscribeToResult(this, duration));\n    }\n  };\n\n  ThrottleSubscriber.prototype.tryDurationSelector = function (value) {\n    try {\n      return this.durationSelector(value);\n    } catch (err) {\n      this.destination.error(err);\n      return null;\n    }\n  };\n\n  ThrottleSubscriber.prototype.throttlingDone = function () {\n    var _a = this,\n        _throttled = _a._throttled,\n        _trailing = _a._trailing;\n\n    if (_throttled) {\n      _throttled.unsubscribe();\n    }\n\n    this._throttled = null;\n\n    if (_trailing) {\n      this.send();\n    }\n  };\n\n  ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.throttlingDone();\n  };\n\n  ThrottleSubscriber.prototype.notifyComplete = function () {\n    this.throttlingDone();\n  };\n\n  return ThrottleSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */\n\n\nvar ThrottleTimeSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(ThrottleTimeSubscriber, _super);\n\n  function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.duration = duration;\n    _this.scheduler = scheduler;\n    _this.leading = leading;\n    _this.trailing = trailing;\n    _this._hasTrailingValue = false;\n    _this._trailingValue = null;\n    return _this;\n  }\n\n  ThrottleTimeSubscriber.prototype._next = function (value) {\n    if (this.throttled) {\n      if (this.trailing) {\n        this._trailingValue = value;\n        this._hasTrailingValue = true;\n      }\n    } else {\n      this.add(this.throttled = this.scheduler.schedule(dispatchNext$1, this.duration, {\n        subscriber: this\n      }));\n\n      if (this.leading) {\n        this.destination.next(value);\n      }\n    }\n  };\n\n  ThrottleTimeSubscriber.prototype._complete = function () {\n    if (this._hasTrailingValue) {\n      this.destination.next(this._trailingValue);\n      this.destination.complete();\n    } else {\n      this.destination.complete();\n    }\n  };\n\n  ThrottleTimeSubscriber.prototype.clearThrottle = function () {\n    var throttled = this.throttled;\n\n    if (throttled) {\n      if (this.trailing && this._hasTrailingValue) {\n        this.destination.next(this._trailingValue);\n        this._trailingValue = null;\n        this._hasTrailingValue = false;\n      }\n\n      throttled.unsubscribe();\n      this.remove(throttled);\n      this.throttled = null;\n    }\n  };\n\n  return ThrottleTimeSubscriber;\n}(Subscriber);\n\nfunction dispatchNext$1(arg) {\n  var subscriber = arg.subscriber;\n  subscriber.clearThrottle();\n}\n/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _scheduler_async,_scan,_observable_defer,_map PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START tslib PURE_IMPORTS_END */\n\n\nvar TimeoutError =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(TimeoutError, _super);\n\n  function TimeoutError() {\n    var _this = _super.call(this, 'Timeout has occurred') || this;\n\n    _this.name = 'TimeoutError';\n    Object.setPrototypeOf(_this, TimeoutError.prototype);\n    return _this;\n  }\n\n  return TimeoutError;\n}(Error);\n/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\n\n\nvar TimeoutWithSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(TimeoutWithSubscriber, _super);\n\n  function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.absoluteTimeout = absoluteTimeout;\n    _this.waitFor = waitFor;\n    _this.withObservable = withObservable;\n    _this.scheduler = scheduler;\n    _this.action = null;\n\n    _this.scheduleTimeout();\n\n    return _this;\n  }\n\n  TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {\n    var withObservable = subscriber.withObservable;\n\n    subscriber._unsubscribeAndRecycle();\n\n    subscriber.add(subscribeToResult(subscriber, withObservable));\n  };\n\n  TimeoutWithSubscriber.prototype.scheduleTimeout = function () {\n    var action = this.action;\n\n    if (action) {\n      this.action = action.schedule(this, this.waitFor);\n    } else {\n      this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));\n    }\n  };\n\n  TimeoutWithSubscriber.prototype._next = function (value) {\n    if (!this.absoluteTimeout) {\n      this.scheduleTimeout();\n    }\n\n    _super.prototype._next.call(this, value);\n  };\n\n  TimeoutWithSubscriber.prototype._unsubscribe = function () {\n    this.action = null;\n    this.scheduler = null;\n    this.withObservable = null;\n  };\n\n  return TimeoutWithSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _scheduler_async,_map PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\n\n\nvar WindowSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(WindowSubscriber, _super);\n\n  function WindowSubscriber(destination) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.window = new Subject();\n    destination.next(_this.window);\n    return _this;\n  }\n\n  WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.openWindow();\n  };\n\n  WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n    this._error(error);\n  };\n\n  WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n    this._complete();\n  };\n\n  WindowSubscriber.prototype._next = function (value) {\n    this.window.next(value);\n  };\n\n  WindowSubscriber.prototype._error = function (err) {\n    this.window.error(err);\n    this.destination.error(err);\n  };\n\n  WindowSubscriber.prototype._complete = function () {\n    this.window.complete();\n    this.destination.complete();\n  };\n\n  WindowSubscriber.prototype._unsubscribe = function () {\n    this.window = null;\n  };\n\n  WindowSubscriber.prototype.openWindow = function () {\n    var prevWindow = this.window;\n\n    if (prevWindow) {\n      prevWindow.complete();\n    }\n\n    var destination = this.destination;\n    var newWindow = this.window = new Subject();\n    destination.next(newWindow);\n  };\n\n  return WindowSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber,_Subject PURE_IMPORTS_END */\n\n\nvar WindowCountSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(WindowCountSubscriber, _super);\n\n  function WindowCountSubscriber(destination, windowSize, startWindowEvery) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.destination = destination;\n    _this.windowSize = windowSize;\n    _this.startWindowEvery = startWindowEvery;\n    _this.windows = [new Subject()];\n    _this.count = 0;\n    destination.next(_this.windows[0]);\n    return _this;\n  }\n\n  WindowCountSubscriber.prototype._next = function (value) {\n    var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;\n    var destination = this.destination;\n    var windowSize = this.windowSize;\n    var windows = this.windows;\n    var len = windows.length;\n\n    for (var i = 0; i < len && !this.closed; i++) {\n      windows[i].next(value);\n    }\n\n    var c = this.count - windowSize + 1;\n\n    if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\n      windows.shift().complete();\n    }\n\n    if (++this.count % startWindowEvery === 0 && !this.closed) {\n      var window_1 = new Subject();\n      windows.push(window_1);\n      destination.next(window_1);\n    }\n  };\n\n  WindowCountSubscriber.prototype._error = function (err) {\n    var windows = this.windows;\n\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().error(err);\n      }\n    }\n\n    this.destination.error(err);\n  };\n\n  WindowCountSubscriber.prototype._complete = function () {\n    var windows = this.windows;\n\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().complete();\n      }\n    }\n\n    this.destination.complete();\n  };\n\n  WindowCountSubscriber.prototype._unsubscribe = function () {\n    this.count = 0;\n    this.windows = null;\n  };\n\n  return WindowCountSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_Subject,_scheduler_async,_Subscriber,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */\n\n\nvar CountedSubject =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(CountedSubject, _super);\n\n  function CountedSubject() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._numberOfNextedValues = 0;\n    return _this;\n  }\n\n  CountedSubject.prototype.next = function (value) {\n    this._numberOfNextedValues++;\n\n    _super.prototype.next.call(this, value);\n  };\n\n  Object.defineProperty(CountedSubject.prototype, \"numberOfNextedValues\", {\n    get: function get() {\n      return this._numberOfNextedValues;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return CountedSubject;\n}(Subject);\n\nvar WindowTimeSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(WindowTimeSubscriber, _super);\n\n  function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.destination = destination;\n    _this.windowTimeSpan = windowTimeSpan;\n    _this.windowCreationInterval = windowCreationInterval;\n    _this.maxWindowSize = maxWindowSize;\n    _this.scheduler = scheduler;\n    _this.windows = [];\n\n    var window = _this.openWindow();\n\n    if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n      var closeState = {\n        subscriber: _this,\n        window: window,\n        context: null\n      };\n      var creationState = {\n        windowTimeSpan: windowTimeSpan,\n        windowCreationInterval: windowCreationInterval,\n        subscriber: _this,\n        scheduler: scheduler\n      };\n\n      _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n\n      _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n    } else {\n      var timeSpanOnlyState = {\n        subscriber: _this,\n        window: window,\n        windowTimeSpan: windowTimeSpan\n      };\n\n      _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n    }\n\n    return _this;\n  }\n\n  WindowTimeSubscriber.prototype._next = function (value) {\n    var windows = this.windows;\n    var len = windows.length;\n\n    for (var i = 0; i < len; i++) {\n      var window_1 = windows[i];\n\n      if (!window_1.closed) {\n        window_1.next(value);\n\n        if (window_1.numberOfNextedValues >= this.maxWindowSize) {\n          this.closeWindow(window_1);\n        }\n      }\n    }\n  };\n\n  WindowTimeSubscriber.prototype._error = function (err) {\n    var windows = this.windows;\n\n    while (windows.length > 0) {\n      windows.shift().error(err);\n    }\n\n    this.destination.error(err);\n  };\n\n  WindowTimeSubscriber.prototype._complete = function () {\n    var windows = this.windows;\n\n    while (windows.length > 0) {\n      var window_2 = windows.shift();\n\n      if (!window_2.closed) {\n        window_2.complete();\n      }\n    }\n\n    this.destination.complete();\n  };\n\n  WindowTimeSubscriber.prototype.openWindow = function () {\n    var window = new CountedSubject();\n    this.windows.push(window);\n    var destination = this.destination;\n    destination.next(window);\n    return window;\n  };\n\n  WindowTimeSubscriber.prototype.closeWindow = function (window) {\n    window.complete();\n    var windows = this.windows;\n    windows.splice(windows.indexOf(window), 1);\n  };\n\n  return WindowTimeSubscriber;\n}(Subscriber);\n\nfunction dispatchWindowTimeSpanOnly(state) {\n  var subscriber = state.subscriber,\n      windowTimeSpan = state.windowTimeSpan,\n      window = state.window;\n\n  if (window) {\n    subscriber.closeWindow(window);\n  }\n\n  state.window = subscriber.openWindow();\n  this.schedule(state, windowTimeSpan);\n}\n\nfunction dispatchWindowCreation(state) {\n  var windowTimeSpan = state.windowTimeSpan,\n      subscriber = state.subscriber,\n      scheduler = state.scheduler,\n      windowCreationInterval = state.windowCreationInterval;\n  var window = subscriber.openWindow();\n  var action = this;\n  var context = {\n    action: action,\n    subscription: null\n  };\n  var timeSpanState = {\n    subscriber: subscriber,\n    window: window,\n    context: context\n  };\n  context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n  action.add(context.subscription);\n  action.schedule(state, windowCreationInterval);\n}\n\nfunction dispatchWindowClose(state) {\n  var subscriber = state.subscriber,\n      window = state.window,\n      context = state.context;\n\n  if (context && context.action && context.subscription) {\n    context.action.remove(context.subscription);\n  }\n\n  subscriber.closeWindow(window);\n}\n/** PURE_IMPORTS_START tslib,_Subject,_Subscription,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\n\n\nvar WindowToggleSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(WindowToggleSubscriber, _super);\n\n  function WindowToggleSubscriber(destination, openings, closingSelector) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.openings = openings;\n    _this.closingSelector = closingSelector;\n    _this.contexts = [];\n\n    _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));\n\n    return _this;\n  }\n\n  WindowToggleSubscriber.prototype._next = function (value) {\n    var contexts = this.contexts;\n\n    if (contexts) {\n      var len = contexts.length;\n\n      for (var i = 0; i < len; i++) {\n        contexts[i].window.next(value);\n      }\n    }\n  };\n\n  WindowToggleSubscriber.prototype._error = function (err) {\n    var contexts = this.contexts;\n    this.contexts = null;\n\n    if (contexts) {\n      var len = contexts.length;\n      var index = -1;\n\n      while (++index < len) {\n        var context_1 = contexts[index];\n        context_1.window.error(err);\n        context_1.subscription.unsubscribe();\n      }\n    }\n\n    _super.prototype._error.call(this, err);\n  };\n\n  WindowToggleSubscriber.prototype._complete = function () {\n    var contexts = this.contexts;\n    this.contexts = null;\n\n    if (contexts) {\n      var len = contexts.length;\n      var index = -1;\n\n      while (++index < len) {\n        var context_2 = contexts[index];\n        context_2.window.complete();\n        context_2.subscription.unsubscribe();\n      }\n    }\n\n    _super.prototype._complete.call(this);\n  };\n\n  WindowToggleSubscriber.prototype._unsubscribe = function () {\n    var contexts = this.contexts;\n    this.contexts = null;\n\n    if (contexts) {\n      var len = contexts.length;\n      var index = -1;\n\n      while (++index < len) {\n        var context_3 = contexts[index];\n        context_3.window.unsubscribe();\n        context_3.subscription.unsubscribe();\n      }\n    }\n  };\n\n  WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    if (outerValue === this.openings) {\n      var closingSelector = this.closingSelector;\n      var closingNotifier = tryCatch(closingSelector)(innerValue);\n\n      if (closingNotifier === errorObject) {\n        return this.error(errorObject.e);\n      } else {\n        var window_1 = new Subject();\n        var subscription = new Subscription();\n        var context_4 = {\n          window: window_1,\n          subscription: subscription\n        };\n        this.contexts.push(context_4);\n        var innerSubscription = subscribeToResult(this, closingNotifier, context_4);\n\n        if (innerSubscription.closed) {\n          this.closeWindow(this.contexts.length - 1);\n        } else {\n          innerSubscription.context = context_4;\n          subscription.add(innerSubscription);\n        }\n\n        this.destination.next(window_1);\n      }\n    } else {\n      this.closeWindow(this.contexts.indexOf(outerValue));\n    }\n  };\n\n  WindowToggleSubscriber.prototype.notifyError = function (err) {\n    this.error(err);\n  };\n\n  WindowToggleSubscriber.prototype.notifyComplete = function (inner) {\n    if (inner !== this.openSubscription) {\n      this.closeWindow(this.contexts.indexOf(inner.context));\n    }\n  };\n\n  WindowToggleSubscriber.prototype.closeWindow = function (index) {\n    if (index === -1) {\n      return;\n    }\n\n    var contexts = this.contexts;\n    var context = contexts[index];\n    var window = context.window,\n        subscription = context.subscription;\n    contexts.splice(index, 1);\n    window.complete();\n    subscription.unsubscribe();\n  };\n\n  return WindowToggleSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START tslib,_Subject,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\n\n\nvar WindowSubscriber$1 =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(WindowSubscriber, _super);\n\n  function WindowSubscriber(destination, closingSelector) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.destination = destination;\n    _this.closingSelector = closingSelector;\n\n    _this.openWindow();\n\n    return _this;\n  }\n\n  WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.openWindow(innerSub);\n  };\n\n  WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n    this._error(error);\n  };\n\n  WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n    this.openWindow(innerSub);\n  };\n\n  WindowSubscriber.prototype._next = function (value) {\n    this.window.next(value);\n  };\n\n  WindowSubscriber.prototype._error = function (err) {\n    this.window.error(err);\n    this.destination.error(err);\n    this.unsubscribeClosingNotification();\n  };\n\n  WindowSubscriber.prototype._complete = function () {\n    this.window.complete();\n    this.destination.complete();\n    this.unsubscribeClosingNotification();\n  };\n\n  WindowSubscriber.prototype.unsubscribeClosingNotification = function () {\n    if (this.closingNotification) {\n      this.closingNotification.unsubscribe();\n    }\n  };\n\n  WindowSubscriber.prototype.openWindow = function (innerSub) {\n    if (innerSub === void 0) {\n      innerSub = null;\n    }\n\n    if (innerSub) {\n      this.remove(innerSub);\n      innerSub.unsubscribe();\n    }\n\n    var prevWindow = this.window;\n\n    if (prevWindow) {\n      prevWindow.complete();\n    }\n\n    var window = this.window = new Subject();\n    this.destination.next(window);\n    var closingNotifier = tryCatch(this.closingSelector)();\n\n    if (closingNotifier === errorObject) {\n      var err = errorObject.e;\n      this.destination.error(err);\n      this.window.error(err);\n    } else {\n      this.add(this.closingNotification = subscribeToResult(this, closingNotifier));\n    }\n  };\n\n  return WindowSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\n\n\nvar WithLatestFromSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(WithLatestFromSubscriber, _super);\n\n  function WithLatestFromSubscriber(destination, observables, project) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.observables = observables;\n    _this.project = project;\n    _this.toRespond = [];\n    var len = observables.length;\n    _this.values = new Array(len);\n\n    for (var i = 0; i < len; i++) {\n      _this.toRespond.push(i);\n    }\n\n    for (var i = 0; i < len; i++) {\n      var observable = observables[i];\n\n      _this.add(subscribeToResult(_this, observable, observable, i));\n    }\n\n    return _this;\n  }\n\n  WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.values[outerIndex] = innerValue;\n    var toRespond = this.toRespond;\n\n    if (toRespond.length > 0) {\n      var found = toRespond.indexOf(outerIndex);\n\n      if (found !== -1) {\n        toRespond.splice(found, 1);\n      }\n    }\n  };\n\n  WithLatestFromSubscriber.prototype.notifyComplete = function () {};\n\n  WithLatestFromSubscriber.prototype._next = function (value) {\n    if (this.toRespond.length === 0) {\n      var args = [value].concat(this.values);\n\n      if (this.project) {\n        this._tryProject(args);\n      } else {\n        this.destination.next(args);\n      }\n    }\n  };\n\n  WithLatestFromSubscriber.prototype._tryProject = function (args) {\n    var result;\n\n    try {\n      result = this.project.apply(this, args);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this.destination.next(result);\n  };\n\n  return WithLatestFromSubscriber;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START tslib,_fromArray,_util_isArray,_Subscriber,_OuterSubscriber,_util_subscribeToResult,_.._internal_symbol_iterator PURE_IMPORTS_END */\n\n\nvar ZipSubscriber =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(ZipSubscriber, _super);\n\n  function ZipSubscriber(destination, resultSelector, values) {\n    if (values === void 0) {\n      values = Object.create(null);\n    }\n\n    var _this = _super.call(this, destination) || this;\n\n    _this.iterators = [];\n    _this.active = 0;\n    _this.resultSelector = typeof resultSelector === 'function' ? resultSelector : null;\n    _this.values = values;\n    return _this;\n  }\n\n  ZipSubscriber.prototype._next = function (value) {\n    var iterators = this.iterators;\n\n    if (isArray(value)) {\n      iterators.push(new StaticArrayIterator(value));\n    } else if (typeof value[iterator] === 'function') {\n      iterators.push(new StaticIterator(value[iterator]()));\n    } else {\n      iterators.push(new ZipBufferIterator(this.destination, this, value));\n    }\n  };\n\n  ZipSubscriber.prototype._complete = function () {\n    var iterators = this.iterators;\n    var len = iterators.length;\n\n    if (len === 0) {\n      this.destination.complete();\n      return;\n    }\n\n    this.active = len;\n\n    for (var i = 0; i < len; i++) {\n      var iterator$$1 = iterators[i];\n\n      if (iterator$$1.stillUnsubscribed) {\n        this.add(iterator$$1.subscribe(iterator$$1, i));\n      } else {\n        this.active--;\n      }\n    }\n  };\n\n  ZipSubscriber.prototype.notifyInactive = function () {\n    this.active--;\n\n    if (this.active === 0) {\n      this.destination.complete();\n    }\n  };\n\n  ZipSubscriber.prototype.checkIterators = function () {\n    var iterators = this.iterators;\n    var len = iterators.length;\n    var destination = this.destination;\n\n    for (var i = 0; i < len; i++) {\n      var iterator$$1 = iterators[i];\n\n      if (typeof iterator$$1.hasValue === 'function' && !iterator$$1.hasValue()) {\n        return;\n      }\n    }\n\n    var shouldComplete = false;\n    var args = [];\n\n    for (var i = 0; i < len; i++) {\n      var iterator$$1 = iterators[i];\n      var result = iterator$$1.next();\n\n      if (iterator$$1.hasCompleted()) {\n        shouldComplete = true;\n      }\n\n      if (result.done) {\n        destination.complete();\n        return;\n      }\n\n      args.push(result.value);\n    }\n\n    if (this.resultSelector) {\n      this._tryresultSelector(args);\n    } else {\n      destination.next(args);\n    }\n\n    if (shouldComplete) {\n      destination.complete();\n    }\n  };\n\n  ZipSubscriber.prototype._tryresultSelector = function (args) {\n    var result;\n\n    try {\n      result = this.resultSelector.apply(this, args);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this.destination.next(result);\n  };\n\n  return ZipSubscriber;\n}(Subscriber);\n\nvar StaticIterator =\n/*@__PURE__*/\nfunction () {\n  function StaticIterator(iterator$$1) {\n    this.iterator = iterator$$1;\n    this.nextResult = iterator$$1.next();\n  }\n\n  StaticIterator.prototype.hasValue = function () {\n    return true;\n  };\n\n  StaticIterator.prototype.next = function () {\n    var result = this.nextResult;\n    this.nextResult = this.iterator.next();\n    return result;\n  };\n\n  StaticIterator.prototype.hasCompleted = function () {\n    var nextResult = this.nextResult;\n    return nextResult && nextResult.done;\n  };\n\n  return StaticIterator;\n}();\n\nvar StaticArrayIterator =\n/*@__PURE__*/\nfunction () {\n  function StaticArrayIterator(array) {\n    this.array = array;\n    this.index = 0;\n    this.length = 0;\n    this.length = array.length;\n  }\n\n  StaticArrayIterator.prototype[iterator] = function () {\n    return this;\n  };\n\n  StaticArrayIterator.prototype.next = function (value) {\n    var i = this.index++;\n    var array = this.array;\n    return i < this.length ? {\n      value: array[i],\n      done: false\n    } : {\n      value: null,\n      done: true\n    };\n  };\n\n  StaticArrayIterator.prototype.hasValue = function () {\n    return this.array.length > this.index;\n  };\n\n  StaticArrayIterator.prototype.hasCompleted = function () {\n    return this.array.length === this.index;\n  };\n\n  return StaticArrayIterator;\n}();\n\nvar ZipBufferIterator =\n/*@__PURE__*/\nfunction (_super) {\n  __extends(ZipBufferIterator, _super);\n\n  function ZipBufferIterator(destination, parent, observable) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.parent = parent;\n    _this.observable = observable;\n    _this.stillUnsubscribed = true;\n    _this.buffer = [];\n    _this.isComplete = false;\n    return _this;\n  }\n\n  ZipBufferIterator.prototype[iterator] = function () {\n    return this;\n  };\n\n  ZipBufferIterator.prototype.next = function () {\n    var buffer = this.buffer;\n\n    if (buffer.length === 0 && this.isComplete) {\n      return {\n        value: null,\n        done: true\n      };\n    } else {\n      return {\n        value: buffer.shift(),\n        done: false\n      };\n    }\n  };\n\n  ZipBufferIterator.prototype.hasValue = function () {\n    return this.buffer.length > 0;\n  };\n\n  ZipBufferIterator.prototype.hasCompleted = function () {\n    return this.buffer.length === 0 && this.isComplete;\n  };\n\n  ZipBufferIterator.prototype.notifyComplete = function () {\n    if (this.buffer.length > 0) {\n      this.isComplete = true;\n      this.parent.notifyInactive();\n    } else {\n      this.destination.complete();\n    }\n  };\n\n  ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.buffer.push(innerValue);\n    this.parent.checkIterators();\n  };\n\n  ZipBufferIterator.prototype.subscribe = function (value, index) {\n    return subscribeToResult(this, this.observable, this, index);\n  };\n\n  return ZipBufferIterator;\n}(OuterSubscriber);\n/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar RxjsTransport =\n/** @class */\nfunction (_super) {\n  __extends(RxjsTransport, _super);\n\n  function RxjsTransport(options) {\n    var _this = _super.call(this) || this;\n\n    _this.subscription = null;\n    _this.connected = false;\n    _this.subject = options.subject;\n    _this.filterFn = options.filterFn === undefined ? function (rawData) {\n      return Boolean(rawData);\n    } : options.filterFn;\n    _this.wrapFn = options.wrapFn === undefined ? function (message) {\n      return {\n        data: message.serialize()\n      };\n    } : options.wrapFn;\n    return _this;\n  }\n\n  RxjsTransport.prototype.disconnect = function () {\n    this.off();\n    this.subscription && this.subscription.unsubscribe();\n    this.connected = false;\n  };\n\n  RxjsTransport.prototype.publish = function (action) {\n    var message = new Message('action', action);\n    this.subject.next(this.wrapFn(message));\n  };\n\n  RxjsTransport.prototype.handshake = function () {\n    if (this.connected) {\n      this.trigger(TransportEvents.connect);\n    } else {\n      this.connect();\n    }\n  };\n\n  RxjsTransport.prototype.connect = function () {\n    var _this = this;\n\n    this.subscription = this.subject.pipe(filter(function (rawData) {\n      return _this.filterFn(rawData);\n    })).subscribe(function (data) {\n      var message = Message.parse('|||' + data.data);\n\n      _this.trigger(TransportEvents.action, message);\n    });\n    this.trigger(TransportEvents.connect, null);\n  };\n\n  return RxjsTransport;\n}(EventEmitter);\n\nvar STACK_LENGTH = 30;\n\nvar Client =\n/** @class */\nfunction () {\n  function Client(transport, dom) {\n    this.transport = transport;\n    this.dom = dom;\n    this.actionStack = [];\n    this.actions = actionMap;\n  }\n\n  Client.prototype.perform = function (rawAction) {\n    if (this.actions.has(rawAction.type)) {\n      var Action = this.actions.get(rawAction.type);\n      var action = new Action(rawAction.payload);\n      action.performEvent(this.dom, this.actionStack);\n      this.actionStack.push(action);\n\n      while (this.actionStack.length > STACK_LENGTH) {\n        this.actionStack.shift();\n      }\n    }\n  };\n\n  Client.prototype.start = function () {\n    var _this = this;\n\n    this.transport.on(TransportEvents.connect, function (event) {\n      _this.dom.init();\n    });\n    this.transport.on(TransportEvents.action, function (event) {\n      var message = event.detail;\n\n      _this.perform(message.data);\n    });\n    this.transport.handshake();\n  };\n\n  Client.prototype.stop = function () {\n    this.transport.disconnect();\n    this.dom.destroy();\n  };\n\n  return Client;\n}();\n\nvar Cursor =\n/** @class */\nfunction () {\n  function Cursor() {\n    this.el = this.createCursorEl();\n  }\n\n  Cursor.prototype.moveTo = function (_a) {\n    var x = _a.x,\n        y = _a.y;\n    this.el.style.transform = \"translateX(\" + x + \"px) translateY(\" + y + \"px)\";\n  };\n\n  Cursor.prototype.getEl = function () {\n    return this.el;\n  };\n\n  Cursor.prototype.destroy = function () {\n    this.el && this.el.remove();\n  };\n\n  Cursor.prototype.createCursorEl = function () {\n    var el = document.createElement('div');\n    css(el, {\n      'z-index': '100500',\n      position: 'fixed',\n      top: '0',\n      left: '0',\n      width: '30px',\n      height: '30px',\n      display: 'inline-block',\n      background: \"url('data:image/png;base64,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')\"\n    });\n    return el;\n  };\n\n  return Cursor;\n}();\n\nvar CURSOR = 1;\n\nvar DomController =\n/** @class */\nfunction () {\n  function DomController(el) {\n    this.el = el;\n    this.cursor = new Cursor();\n  }\n\n  DomController.prototype.init = function () {\n    this.cursor.moveTo({\n      x: 0,\n      y: 0\n    });\n    var bodyEl = document.body;\n\n    if (getComputedStyle(this.el).position !== 'static') {\n      this.el.appendChild(this.cursor.getEl());\n    } else {\n      bodyEl.appendChild(this.cursor.getEl());\n    }\n  };\n\n  DomController.prototype.destroy = function () {\n    this.cursor.destroy();\n  };\n\n  DomController.prototype.moveCursorTo = function (coordinates) {\n    var absCoordinates = this.getAbsoluteCoordinates(coordinates);\n    var payload = this.getMouseEventPayload(coordinates);\n\n    if (payload === null) {\n      return;\n    }\n\n    this.fireEvent.apply(this, ['mousemove'].concat(payload));\n    this.cursor.moveTo(absCoordinates);\n  };\n\n  DomController.prototype.mouseDownTo = function (coordinates) {\n    var payload = this.getMouseEventPayload(coordinates);\n\n    if (payload === null) {\n      return;\n    }\n\n    this.fireEvent.apply(this, ['mousedown'].concat(payload));\n  };\n\n  DomController.prototype.mouseUpTo = function (coordinates) {\n    var payload = this.getMouseEventPayload(coordinates);\n\n    if (payload === null) {\n      return;\n    }\n\n    this.fireEvent.apply(this, ['mouseup'].concat(payload));\n  };\n\n  DomController.prototype.clickTo = function (coordinates) {\n    var payload = this.getMouseEventPayload(coordinates);\n\n    if (payload === null) {\n      return;\n    }\n\n    var el = payload[0],\n        options = payload[1];\n\n    if (document.activeElement !== null) {\n      this.fireEvent('blur', document.activeElement);\n    }\n\n    this.setFocus(el);\n    this.fireEvent('focus', el);\n    this.fireEvent('click', el, options);\n  };\n\n  DomController.prototype.rightClickTo = function (event) {\n    var x = event.x,\n        y = event.y,\n        button = event.button;\n    var payload = this.getMouseEventPayload({\n      x: x,\n      y: y\n    });\n\n    if (payload === null) {\n      return;\n    }\n\n    var el = payload[0],\n        options = payload[1];\n    options = _assign({}, options, {\n      button: button\n    });\n    this.fireEvent('contextmenu', el, options);\n  };\n\n  DomController.prototype.dblClickTo = function (coordinates) {\n    var el = this.getElementFromPoint(this.getAbsoluteCoordinates(coordinates));\n\n    if (!el) {\n      return;\n    }\n\n    switch (el.tagName.toLowerCase()) {\n      case 'textarea':\n      case 'input':\n        el.select();\n        break;\n\n      default:\n        break;\n    }\n\n    this.fireEvent('dblclick', el);\n  };\n\n  DomController.prototype.keydown = function (payload) {\n    var el = document.activeElement;\n\n    if (!el) {\n      return;\n    }\n\n    if (payload.code === 'Backspace') {\n      switch (el.tagName.toLowerCase()) {\n        case 'textarea':\n        case 'input':\n          var inputEl = el;\n\n          if (['checkbox', 'radio'].includes(inputEl.type) || !inputEl.value) {\n            break;\n          }\n\n          inputEl.value = el.value.slice(0, -1);\n          break;\n\n        default:\n          if (el.isContentEditable) {\n            el.innerHTML = el.innerHTML.slice(0, -1);\n          }\n\n          break;\n      }\n    }\n\n    this.fireEvent('keydown', el, payload);\n  };\n\n  DomController.prototype.keyup = function (payload) {\n    var el = document.activeElement;\n\n    if (!el) {\n      return;\n    }\n\n    this.fireEvent('keyup', el, payload);\n  };\n\n  DomController.prototype.keypress = function (event) {\n    var el = document.activeElement;\n\n    if (!el || event.keyCode === undefined) {\n      return;\n    }\n\n    this.fireEvent('keypress', el, event);\n\n    switch (el.tagName.toLowerCase()) {\n      case 'textarea':\n      case 'input':\n        el.value += String.fromCharCode(event.keyCode);\n        break;\n\n      default:\n        el.innerHTML += String.fromCharCode(event.keyCode);\n        break;\n    }\n\n    this.fireEvent('input', el, event);\n  };\n\n  DomController.prototype.scroll = function (_a) {\n    var x = _a.x,\n        y = _a.y,\n        deltaX = _a.deltaX,\n        deltaY = _a.deltaY;\n    var initialEl = this.getElementFromPoint(this.getAbsoluteCoordinates({\n      x: x,\n      y: y\n    }));\n    var scrollableEl;\n    var el = initialEl;\n\n    if (!el) {\n      return;\n    }\n\n    while (el && el.parentElement) {\n      if (this.isScrollable(el)) {\n        scrollableEl = el;\n        break;\n      }\n\n      el = el.parentElement;\n    }\n\n    if (!scrollableEl) {\n      scrollableEl = document.body;\n    }\n\n    scrollableEl.scrollBy({\n      left: deltaX,\n      top: deltaY\n    });\n    this.fireEvent('wheel', el);\n    this.fireEvent('scroll', el);\n  };\n\n  DomController.prototype.getMouseEventPayload = function (coordinates) {\n    var absCoordinates = this.getAbsoluteCoordinates(coordinates);\n    var el = this.getElementFromPoint(absCoordinates);\n\n    if (!el) {\n      return null;\n    }\n\n    var options = {\n      clientX: absCoordinates.x,\n      clientY: absCoordinates.y,\n      view: window\n    };\n    return [el, options];\n  };\n\n  DomController.prototype.getAbsoluteCoordinates = function (_a) {\n    var x = _a.x,\n        y = _a.y;\n    var innerHeight = window.innerHeight,\n        innerWidth = window.innerWidth;\n    return {\n      x: x * innerWidth,\n      y: y * innerHeight\n    };\n  };\n\n  DomController.prototype.getElementFromPoint = function (_a) {\n    var x = _a.x,\n        y = _a.y;\n    return document.elementFromPoint(x - CURSOR, y - CURSOR);\n  };\n\n  DomController.prototype.setFocus = function (el) {\n    if (el.focus) {\n      el.focus();\n    }\n  };\n\n  DomController.prototype.fireEvent = function (type, el, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var event;\n    var defaultOptions = {\n      bubbles: true,\n      cancelable: true\n    };\n\n    switch (type) {\n      case 'click':\n      case 'dblclick':\n      case 'mousedown':\n      case 'mouseup':\n      case 'contextmenu':\n      case 'mousemove':\n        event = new MouseEvent(type, _assign({}, defaultOptions, options));\n        break;\n\n      case 'keypress':\n      case 'keydown':\n      case 'keyup':\n        event = new KeyboardEvent(type, _assign({}, defaultOptions, options));\n        break;\n\n      default:\n        event = new Event(type, _assign({}, defaultOptions, options));\n        break;\n    }\n\n    if (window[DEBUG_FLAG]) {\n      console.log('fired', event);\n    }\n\n    return el.dispatchEvent(event);\n  };\n\n  DomController.prototype.isScrollable = function (el) {\n    return this.isScrollableY(el) || this.isScrollableX(el);\n  };\n\n  DomController.prototype.isScrollableX = function (el) {\n    var style = getComputedStyle(el);\n    return ['auto', 'scroll'].includes(style.overflowX) && el.scrollWidth > el.clientWidth;\n  };\n\n  DomController.prototype.isScrollableY = function (el) {\n    var style = getComputedStyle(el);\n    return ['auto', 'scroll'].includes(style.overflowY) && el.scrollHeight > el.clientHeight;\n  };\n\n  return DomController;\n}();\n\nvar Host =\n/** @class */\nfunction () {\n  function Host(transport, el) {\n    this.transport = transport;\n    this.el = el;\n    this.actions = actionMap;\n    this.eventCallbacks = new WeakMap();\n  }\n\n  Host.prototype.start = function () {\n    this.initEvents();\n    this.transport.handshake();\n  };\n\n  Host.prototype.stop = function () {\n    this.transport.disconnect();\n    this.disableEvents();\n  };\n\n  Host.prototype.initEvents = function () {\n    var _this = this;\n\n    this.actions.forEach(function (Action) {\n      _this.eventCallbacks.set(Action, function (event) {\n        var action = Action.handleEvent(_this, event);\n\n        _this.transport.publish(action);\n      });\n\n      _this.el.addEventListener(Action.eventName, _this.eventCallbacks.get(Action));\n    });\n  };\n\n  Host.prototype.disableEvents = function () {\n    var _this = this;\n\n    this.actions.forEach(function (Action) {\n      return _this.el.removeEventListener(Action.eventName, _this.eventCallbacks.get(Action));\n    });\n  };\n\n  Host.prototype.getRelativeCoordinate = function (event) {\n    var offsetX = event.offsetX,\n        offsetY = event.offsetY;\n    var _a = event.target,\n        clientHeight = _a.clientHeight,\n        clientWidth = _a.clientWidth;\n    return {\n      x: offsetX / clientWidth,\n      y: offsetY / clientHeight\n    };\n  };\n\n  return Host;\n}();\n\nvar localTransport = new LocalTransport();\n\nfunction createClient(el, transport) {\n  if (transport === void 0) {\n    transport = localTransport;\n  }\n\n  return new Client(transport, new DomController(el));\n}\n\nfunction createHost(el, transport) {\n  if (transport === void 0) {\n    transport = localTransport;\n  }\n\n  return new Host(transport, el);\n}\n\nexport { createClient, createHost, DEBUG_FLAG, Client, Host, TransportEvents, LocalTransport, RxjsTransport, Message, EventEmitter, actionMap, MoveToAction, ClickToAction, KeypressAction, ScrollByAction, DblClickToAction, KeydownAction, KeyupAction, RightClickToAction, MouseDownToAction, MouseUpToAction, ActionsName, BaseAction };","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nexport default function _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}","import _typeof from \"../../helpers/esm/typeof\";\nimport assertThisInitialized from \"./assertThisInitialized\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","'use strict';\n\nvar has = Object.prototype.hasOwnProperty,\n    prefix = '~';\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\n\nfunction Events() {} //\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\n\n\nif (Object.create) {\n  Events.prototype = Object.create(null); //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n\n  if (!new Events().__proto__) prefix = false;\n}\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\n\n\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\n\n\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once),\n      evt = prefix ? prefix + event : event;\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];\n  return emitter;\n}\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\n\n\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];\n}\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\n\n\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\n\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = [],\n      events,\n      name;\n  if (this._eventsCount === 0) return names;\n\n  for (name in events = this._events) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\n\n\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event,\n      handlers = this._events[evt];\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\n\n\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event,\n      listeners = this._events[evt];\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\n\n\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n  if (!this._events[evt]) return false;\n  var listeners = this._events[evt],\n      len = arguments.length,\n      args,\n      i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1:\n        return listeners.fn.call(listeners.context), true;\n\n      case 2:\n        return listeners.fn.call(listeners.context, a1), true;\n\n      case 3:\n        return listeners.fn.call(listeners.context, a1, a2), true;\n\n      case 4:\n        return listeners.fn.call(listeners.context, a1, a2, a3), true;\n\n      case 5:\n        return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n\n      case 6:\n        return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len - 1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length,\n        j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1:\n          listeners[i].fn.call(listeners[i].context);\n          break;\n\n        case 2:\n          listeners[i].fn.call(listeners[i].context, a1);\n          break;\n\n        case 3:\n          listeners[i].fn.call(listeners[i].context, a1, a2);\n          break;\n\n        case 4:\n          listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n          break;\n\n        default:\n          if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\n\n\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\n\n\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\n\n\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n  if (!this._events[evt]) return this;\n\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n        events.push(listeners[i]);\n      }\n    } //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n\n\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);\n  }\n\n  return this;\n};\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\n\n\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n}; //\n// Alias methods names because people roll like that.\n//\n\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on; //\n// Expose the prefix.\n//\n\nEventEmitter.prefixed = prefix; //\n// Allow `EventEmitter` to be imported as module namespace.\n//\n\nEventEmitter.EventEmitter = EventEmitter; //\n// Expose the module.\n//\n\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}","export default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}","export default function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"./defineProperty\";\nexport default function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}"],"sourceRoot":""}