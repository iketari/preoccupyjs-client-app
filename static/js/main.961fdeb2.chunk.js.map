{"version":3,"sources":["components/video-screen/VideoScreen.tsx","modules/websocket.service.ts","components/message/Message.tsx","modules/webrtc.service.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["VideoScreen","react_default","a","createElement","autoPlay","muted","id","this","props","idAttr","className","React","Component","WebSocketService","ws","user","onMessageCallbacks","onRegisterCb","cb","push","_this","WebSocket","onmessage","e","data","JSON","parse","action","payload","forEach","Error","from","send","stringify","message","name","to","Message","item","WebRTCService","serverConnection","Object","classCallCheck","peerUserName","localVideo","localStream","remoteVideo","peerConnection","uuid","peerConnectionConfig","iceServers","urls","gotMessageFromServer","start","signal","console","log","sdp","setRemoteDescription","RTCSessionDescription","then","type","createAnswer","createdDescription","catch","errorHandler","ice","addIceCandidate","RTCIceCandidate","gotIceCandidate","event","candidate","communicate","description","setLocalDescription","localDescription","gotRemoteStream","srcObject","streams","getUserMediaSuccess","stream","error","createUUID","document","getElementById","onMessage","navigator","mediaDevices","getUserMedia","video","audio","alert","isCaller","undefined","RTCPeerConnection","onicecandidate","ontrack","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","getTracks","Symbol","iterator","next","done","track","value","addTrack","err","return","createOffer","s4","Math","floor","random","toString","substring","App","possibleConstructorReturn","getPrototypeOf","call","webRtc","toNameRef","createRef","toMessageRef","handleOnStartCallClick","nameValue","current","handleOnSendMessageClick","messageValue","state","messages","_this2","Container","Row","Col","VideoScreen_VideoScreen","Button","onClick","handleOnRegisterClick","variant","ref","placeholder","map","index","key","Message_Message","_this3","connect","onRegister","result","setState","concat","toConsumableArray","initWebRTC","prompt","register","init","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.961fdeb2.chunk.js","sourcesContent":["import React from 'react';\nimport './VideoScreen.css';\n\nexport interface IVideoScreenProps {\n  idAttr: string;\n}\n\nexport default class VideoScreen extends React.Component<IVideoScreenProps, any> {\n  render() {\n    return (\n      <video autoPlay muted id={this.props.idAttr} className=\"video\"></video>\n    );\n  }\n}","const SOCKET_URL = 'wss://r12aimxa21.execute-api.eu-west-2.amazonaws.com/Prod';\n\nexport interface IMessage {\n  from: string;\n  to?: string;\n  message: string;\n}\n\nexport default class WebSocketService {\n  ws: WebSocket | null = null;\n  user: string | null = null;\n  onMessageCallbacks: ((msg: IMessage) => void)[] = [];\n  onRegisterCb: (result: boolean, name?: string) => void = () => {};\n\n  setUser(user: string) {\n    this.user = user;\n  }\n\n  onMessage(cb: (msg: IMessage) => void) {\n    this.onMessageCallbacks.push(cb);\n  }\n\n  onRegister(cb: (result: boolean, name?: string) => void) {\n    this.onRegisterCb = cb;\n  }\n\n  connect() {\n    this.ws = new WebSocket(SOCKET_URL);\n    this.ws.onmessage = (e) => {\n      const data = JSON.parse(e.data);\n\n      switch (data.action) {\n        case 'registerSuccess':\n          this.onRegisterCb(true, data.payload);\n          break;\n        \n        case 'communticate':\n          this.onMessageCallbacks.forEach(cb =>cb(data.payload));\n          break;\n      \n        default:\n          this.onRegisterCb(false);\n          break;\n      }\n    }\n  }\n\n  send(data: any) {\n    if (!this.ws) {\n      throw new Error('Connection is lost or has not been established yet');\n    }\n\n    if (this.user) {\n      data.from = this.user;\n    }\n\n    this.ws.send(JSON.stringify({\n      message: 'sendmessage',\n      data\n    }));\n  }\n\n  register(name: string) {\n    this.send({\n      action: 'register',\n      payload: name\n    });\n  }\n\n  communicate(to: string, message:string) {\n    this.send({\n      action: 'communicate',\n      payload: {\n        to,\n        message\n      }\n    });\n  }\n}","import React from 'react';\nimport { IMessage } from '../../modules/websocket.service';\nimport './Message.css';\n\nexport interface IMessageProps {\n  item: IMessage\n}\n\nexport default class Message extends React.Component<IMessageProps, object> {\n  render() {\n    return (<div className=\"message\">\n      <span className=\"message__title\">{this.props.item.from}</span>\n      <div>{this.props.item.message}</div>\n    </div>);\n  }\n}","import WebSocketService, { IMessage } from \"./websocket.service\";\n\nexport interface ISignalMessage {\n  uuid: string;\n  ice?: RTCIceCandidateInit;\n  sdp?: RTCSessionDescriptionInit;\n}\n\ninterface ISignalMessageSdp extends ISignalMessage {\n  sdp: RTCSessionDescriptionInit;\n}\n\nexport default class WebRTCService {\n  peerUserName: string | null = null;\n  localVideo: HTMLVideoElement | null = null;\n  localStream: MediaStream | null = null;\n  remoteVideo: HTMLVideoElement | null = null;\n  peerConnection: RTCPeerConnection | null = null;\n  uuid: string | null = null;\n  \n  peerConnectionConfig = {\n    'iceServers': [\n      {'urls': 'stun:stun.stunprotocol.org:3478'},\n      {'urls': 'stun:stun.l.google.com:19302'},\n    ]\n  };\n\n  constructor(private serverConnection: WebSocketService) {}\n  \n  init(localVideo: string, remoteVideo: string) {\n    this.uuid = this.createUUID();\n  \n    this.localVideo = document.getElementById(localVideo) as HTMLVideoElement;\n    this.remoteVideo = document.getElementById(remoteVideo) as HTMLVideoElement;\n\n    this.serverConnection.onMessage(this.gotMessageFromServer);\n  \n    const constraints = {\n      video: true,\n      audio: true,\n    };\n  \n    if(navigator.mediaDevices.getUserMedia) {\n      navigator.mediaDevices.getUserMedia(constraints)\n        .then(this.getUserMediaSuccess)\n        .catch(this.errorHandler);\n    } else {\n      alert('Your browser does not support getUserMedia API');\n    }\n  }\n\n  start(peerUserName?: string) {\n    const isCaller = peerUserName !== undefined;\n    if (!this.localStream) {\n      throw new Error('No localStream');\n    }\n\n    const peerConnection = new RTCPeerConnection(this.peerConnectionConfig);\n    peerConnection.onicecandidate = this.gotIceCandidate;\n    peerConnection.ontrack = this.gotRemoteStream;\n\n    for (const track of this.localStream.getTracks()) {\n      peerConnection.addTrack(track, this.localStream);\n    }\n\n    this.peerConnection = peerConnection;\n  \n    if(isCaller) {\n      this.peerUserName = peerUserName as string;\n      peerConnection.createOffer()\n        .then(this.createdDescription)\n        .catch(this.errorHandler);\n    }\n  }\n\n  private gotMessageFromServer = (message: IMessage) => {\n    if(!this.peerConnection) {\n      this.start();\n    }\n    const peerConnection = this.peerConnection as RTCPeerConnection;\n    let signal: ISignalMessage;\n    try {\n      signal = JSON.parse(message.message);\n    } catch (e) {\n      return;\n    }\n  \n    // Ignore messages from ourself\n    if(!signal.uuid || signal.uuid === this.uuid) return;\n    this.peerUserName = message.from;\n  console.log(signal);\n    if(signal.sdp) {\n      const sdp = (signal as ISignalMessageSdp).sdp;\n      peerConnection.setRemoteDescription(new RTCSessionDescription(signal.sdp))\n      .then(() => {\n        // Only create answers in response to offers\n        if(sdp.type === 'offer') {\n          peerConnection.createAnswer().then(this.createdDescription).catch(this.errorHandler);\n        }\n      }).catch(this.errorHandler);\n    } else if(signal.ice) {\n      peerConnection.addIceCandidate(new RTCIceCandidate(signal.ice)).catch(this.errorHandler);\n    }\n  }\n\n  private gotIceCandidate = (event: RTCPeerConnectionIceEvent) => {\n    if (event.candidate != null) {\n      this.serverConnection.communicate(this.peerUserName as string, JSON.stringify({\n        ice: event.candidate,\n        uuid: this.uuid\n      }));\n    }\n  }\n\n  private createdDescription = (description: RTCSessionDescriptionInit) => {\n    const peerConnection = this.peerConnection;\n    if (!peerConnection) {\n      throw new Error('No peerConnection');\n    }\n  \n    peerConnection.setLocalDescription(description).then(() => {\n      this.serverConnection\n        .communicate(this.peerUserName as string, JSON.stringify({\n          'sdp': peerConnection.localDescription,\n          'uuid': this.uuid\n        }));\n    }).catch(this.errorHandler);\n  }\n\n  private gotRemoteStream = (event: RTCTrackEvent) => {\n    if (!this.remoteVideo) {\n      throw new Error('No remoteVideo element');\n    }\n\n    this.remoteVideo.srcObject = event.streams[0];\n  }\n\n  private getUserMediaSuccess = (stream: MediaStream) => {\n    if (!this.localVideo) {\n      throw new Error('No localVideo element');\n    }\n    this.localStream = stream;\n    this.localVideo.srcObject = stream;\n  }\n  \n  private errorHandler = (error: any) => {\n    console.log(error);\n  }\n  \n  // Taken from http://stackoverflow.com/a/105074/515584\n  // Strictly speaking, it's not a real UUID, but it gets the job done here\n  private createUUID() {\n    function s4() {\n      return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n    }\n\n    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n  }\n\n}\n\n\n\n\n\n\n\n","import React, { RefObject } from 'react';\nimport { Container, Row, Col, Button } from 'react-bootstrap';\nimport VideoScreen from './components/video-screen/VideoScreen';\nimport './App.css';\nimport WebSocketService, { IMessage } from './modules/websocket.service';\nimport Message from './components/message/Message';\nimport WebRTCService from './modules/webrtc.service';\n\ninterface IAppState {\n  name: string | null;\n  messages: IMessage[];\n}\n\nclass App extends React.Component<unknown, IAppState> {\n  ws: WebSocketService = new WebSocketService();\n  webRtc: WebRTCService = new WebRTCService(this.ws);\n\n  toNameRef: RefObject<HTMLInputElement> = React.createRef<HTMLInputElement>();\n  toMessageRef: RefObject<HTMLTextAreaElement> = React.createRef<HTMLTextAreaElement>();\n\n  constructor(props: unknown) {\n    super(props);\n\n    this.state = {\n      name: null,\n      messages: []\n    };\n  }\n\n  render() {\n    return (\n      <Container>\n        <Row>\n          <Col>\n            <VideoScreen idAttr=\"localVideo\" />\n          </Col>\n          <Col>\n            <VideoScreen idAttr=\"remoteVideo\" />\n          </Col>\n        </Row>\n        <Row>\n          <Col>\n            <Button onClick={() => this.handleOnRegisterClick()} variant=\"primary\">Register</Button>\n          </Col>\n          <Col>\n            <Button onClick={this.handleOnStartCallClick} variant=\"success\">Call</Button>\n            <Button variant=\"danger\">Abort call</Button>\n          </Col>\n          <Col>Logged in as: {this.state.name}</Col>\n        </Row>\n        <Row>\n          <Col>\n            <input ref={this.toNameRef} placeholder=\"Message to...\" type=\"text\"/>\n            <textarea ref={this.toMessageRef} placeholder=\"Message body...\"></textarea>\n          </Col>\n          <Col>\n            <Button onClick={this.handleOnSendMessageClick} variant=\"secondary\">Send message</Button>\n          </Col>\n          <Col>\n            Messages: {this.state.messages.map((message, index) => (\n              <div key={index}>\n                <Message item={message} />\n                <hr/>\n              </div>\n            ))}\n          </Col>\n        </Row>\n      </Container>\n    );\n  }\n\n  componentDidMount() {\n    this.ws.connect();\n\n    this.ws.onRegister((result, name) => {\n      this.setState({name: result && name ? name : null});\n    });\n\n    this.ws.onMessage((message: IMessage) => {\n      this.setState({\n        messages: [\n          ...this.state.messages,\n          message\n        ]\n      })\n    });\n\n    this.initWebRTC();\n  }\n\n  handleOnRegisterClick() {\n    const name = prompt('Enter a name');\n    if (name) {\n      this.ws.register(name);\n    }\n  }\n\n  handleOnStartCallClick = () => {\n    const nameValue = this.toNameRef.current && this.toNameRef.current.value;\n    if (!nameValue) {\n      return;\n    }\n\n    this.webRtc.start(nameValue);\n  }\n\n  handleOnSendMessageClick = () => {\n    const nameValue = this.toNameRef.current && this.toNameRef.current.value;\n    const messageValue = this.toMessageRef.current && this.toMessageRef.current.value;\n\n    if (!nameValue || !messageValue) {\n      return;\n    }\n\n    this.ws.communicate(nameValue, messageValue);\n  }\n\n  private initWebRTC() {\n    this.webRtc.init('localVideo', 'remoteVideo');\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'bootstrap/dist/css/bootstrap.css';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}